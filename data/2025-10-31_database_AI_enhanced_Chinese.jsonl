{"id": "2510.24761", "pdf": "https://arxiv.org/pdf/2510.24761", "abs": "https://arxiv.org/abs/2510.24761", "authors": ["Anirudh Ganesh", "Nitin Sood"], "title": "ODataX: A Progressive Evolution of the Open Data Protocol", "categories": ["cs.DB", "cs.IR", "cs.SE"], "comment": null, "summary": "The Open Data Protocol (OData) provides a standardized approach for building\nand consuming RESTful APIs with rich query capabilities. Despite its power and\nmaturity, OData adoption remains confined primarily to enterprise environments,\nparticularly within Microsoft and SAP ecosystems. This paper analyzes the key\nbarriers preventing wider OData adoption and introduces ODataX, an evolved\nversion of the protocol designed to address these limitations. ODataX maintains\nbackward compatibility with OData v4 while introducing progressive complexity\ndisclosure through simplified query syntax, built-in performance guardrails via\nquery cost estimation, and enhanced caching mechanisms. This work aims to\nbridge the gap between enterprise-grade query standardization and the\nsimplicity demanded by modern web development practices.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.25017", "pdf": "https://arxiv.org/pdf/2510.25017", "abs": "https://arxiv.org/abs/2510.25017", "authors": ["Qi Lin", "Zhenyu Zhang", "Viraj Thakkar", "Zhenjie Sun", "Mai Zheng", "Zhichao Cao"], "title": "StorageXTuner: An LLM Agent-Driven Automatic Tuning Framework for Heterogeneous Storage Systems", "categories": ["cs.DB", "cs.AI", "cs.CL"], "comment": "ArXiv version; Affiliations: Arizona State University (Lin, Zhang,\n  Thakkar, Sun, Cao) and Iowa State University (Zheng)", "summary": "Automatically configuring storage systems is hard: parameter spaces are large\nand conditions vary across workloads, deployments, and versions. Heuristic and\nML tuners are often system specific, require manual glue, and degrade under\nchanges. Recent LLM-based approaches help but usually treat tuning as a\nsingle-shot, system-specific task, which limits cross-system reuse, constrains\nexploration, and weakens validation. We present StorageXTuner, an LLM\nagent-driven auto-tuning framework for heterogeneous storage engines.\nStorageXTuner separates concerns across four agents - Executor (sandboxed\nbenchmarking), Extractor (performance digest), Searcher (insight-guided\nconfiguration exploration), and Reflector (insight generation and management).\nThe design couples an insight-driven tree search with layered memory that\npromotes empirically validated insights and employs lightweight checkers to\nguard against unsafe actions. We implement a prototype and evaluate it on\nRocksDB, LevelDB, CacheLib, and MySQL InnoDB with YCSB, MixGraph, and TPC-H/C.\nRelative to out-of-the-box settings and to ELMo-Tune, StorageXTuner reaches up\nto 575% and 111% higher throughput, reduces p99 latency by as much as 88% and\n56%, and converges with fewer trials.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.25143", "pdf": "https://arxiv.org/pdf/2510.25143", "abs": "https://arxiv.org/abs/2510.25143", "authors": ["Mingze Xia", "Yuxiao Li", "Pu Jiao", "Bei Wang", "Xin Liang", "Hanqi Guo"], "title": "Time-varying Vector Field Compression with Preserved Critical Point Trajectories", "categories": ["cs.DB"], "comment": null, "summary": "Scientific simulations and observations are producing vast amounts of\ntime-varying vector field data, making it hard to store them for archival\npurposes and transmit them for analysis. Lossy compression is considered a\npromising approach to reducing these data because lossless compression yields\nlow compression ratios that barely mitigate the problem. However, directly\napplying existing lossy compression methods to timevarying vector fields may\nintroduce undesired distortions in critical-point trajectories, a crucial\nfeature that encodes key properties of the vector field. In this work, we\npropose an efficient lossy compression framework that exactly preserves all\ncritical-point trajectories in time-varying vector fields. Our contributions\nare threefold. First, we extend the theory for preserving critical points in\nspace to preserving critical-point trajectories in space-time, and develop a\ncompression framework to realize the functionality. Second, we propose a\nsemi-Lagrange predictor to exploit the spatiotemporal correlations in\nadvectiondominated regions, and combine it with the traditional Lorenzo\npredictor for improved compression efficiency. Third, we evaluate our method\nagainst state-of-the-art lossy and lossless compressors using four real-world\nscientific datasets. Experimental results demonstrate that the proposed method\ndelivers up to 124.48X compression ratios while effectively preserving all\ncritical-point trajectories. This compression ratio is up to 56.07X higher than\nthat of the best lossless compressors, and none of the existing lossy\ncompressors can preserve all critical-point trajectories at similar compression\nratios.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.25401", "pdf": "https://arxiv.org/pdf/2510.25401", "abs": "https://arxiv.org/abs/2510.25401", "authors": ["Jiahao Lou", "Quan Yu", "Shufeng Gong", "Song Yu", "Yanfeng Zhang", "Ge Yu"], "title": "DGAI: Decoupled On-Disk Graph-Based ANN Index for Efficient Updates and Queries", "categories": ["cs.DB"], "comment": "12 pages", "summary": "On-disk graph-based indexes are widely used in approximate nearest neighbor\n(ANN) search systems for large-scale, high-dimensional vectors. However,\ntraditional coupled storage methods, which store vectors within the index, are\ninefficient for index updates. Coupled storage incurs excessive redundant\nvector reads and writes when updating the graph topology, leading to\nsignificant invalid I/O. To address this issue, we propose a decoupled storage\narchitecture. While a decoupled architecture reduces query performance. To\novercome this limitation, we design two tailored strategies: (i) a three-stage\nquery mechanism that leverages multiple PQ compressed vectors to filter invalid\nI/O and computations, and (ii) an incremental page-level topological reordering\nstrategy that incrementally inserts new nodes into pages containing their most\nsimilar neighbors to mitigate read amplification. Together, these techniques\nsubstantially reduce both I/O and computational overhead during ANN search.\nExperimental results show that the decoupled architecture improves update speed\nby 10.05x for insertions and 6.89x for deletions, while the three-stage query\nand incremental reordering enhance query efficiency by 2.66x compared to the\ntraditional coupled architecture.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.25684", "pdf": "https://arxiv.org/pdf/2510.25684", "abs": "https://arxiv.org/abs/2510.25684", "authors": ["Yujun He", "Hangdong Zhao", "Simon Frisk", "Yifei Yang", "Kevin Kristensen", "Paraschos Koutris", "Xiangyao Yu"], "title": "One Join Order Does Not Fit All: Reducing Intermediate Results with Per-Split Query Plans", "categories": ["cs.DB"], "comment": null, "summary": "Minimizing intermediate results is critical for efficient multi-join query\nprocessing. Although the seminal Yannakakis algorithm offers strong guarantees\nfor acyclic queries, cyclic queries remain an open challenge. In this paper, we\npropose SplitJoin, a framework that introduces split as a first-class query\noperator. By partitioning input tables into heavy and light parts, SplitJoin\nallows different data partitions to use distinct query plans, with the goal of\nreducing intermediate sizes using existing binary join engines. We\nsystematically explore the design space for split-based optimizations,\nincluding threshold selection, split strategies, and join ordering after\nsplits. Implemented as a front-end to DuckDB and Umbra, SplitJoin achieves\nsubstantial improvements: on DuckDB, SplitJoin completes 43 social network\nqueries (vs. 29 natively), achieving 2.1x faster runtime and 7.9x smaller\nintermediates on average (up to 13.6x and 74x, respectively); on Umbra, it\ncompletes 45 queries (vs. 35), achieving 1.3x speedups and 1.2x smaller\nintermediates on average (up to 6.1x and 2.1x, respectively).", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
