{"id": "2506.17226", "pdf": "https://arxiv.org/pdf/2506.17226", "abs": "https://arxiv.org/abs/2506.17226", "authors": ["Ashish Manchanda", "Prem Prakash Jayaraman", "Abhik Banerjee", "Kaneez Fizza", "Arkady Zaslavsky"], "title": "DCMF: A Dynamic Context Monitoring and Caching Framework for Context Management Platforms", "categories": ["cs.DB"], "comment": null, "summary": "The rise of context-aware IoT applications has increased the demand for\ntimely and accurate context information. Context is derived by aggregating and\ninferring from dynamic IoT data, making it highly volatile and posing\nchallenges in maintaining freshness and real-time accessibility. Caching is a\npotential solution, but traditional policies struggle with the transient nature\nof context in IoT (e.g., ensuring real-time access for frequent queries or\nhandling fast-changing data). To address this, we propose the Dynamic Context\nMonitoring Framework (DCMF) to enhance context caching in Context Management\nPlatforms (CMPs) by dynamically evaluating and managing context. DCMF comprises\ntwo core components: the Context Evaluation Engine (CEE) and the Context\nManagement Module (CMM). The CEE calculates the Probability of Access (PoA)\nusing parameters such as Quality of Service (QoS), Quality of Context (QoC),\nCost of Context (CoC), timeliness, and Service Level Agreements (SLAs),\nassigning weights to assess access likelihood. Based on this, the CMM applies a\nhybrid Dempster-Shafer approach to manage Context Freshness (CF), updating\nbelief levels and confidence scores to determine whether to cache, evict, or\nrefresh context items. We implemented DCMF in a Context-as-a-Service (CoaaS)\nplatform and evaluated it using real-world smart city data, particularly\ntraffic and roadwork scenarios. Results show DCMF achieves a 12.5% higher cache\nhit rate and reduces cache expiry by up to 60% compared to the m-CAC technique,\nensuring timely delivery of relevant context and reduced latency. These results\ndemonstrate DCMF's scalability and suitability for dynamic context-aware IoT\nenvironments.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.17451", "pdf": "https://arxiv.org/pdf/2506.17451", "abs": "https://arxiv.org/abs/2506.17451", "authors": ["Aida Sheshbolouki", "M. Tamer Ozsu"], "title": "Transient Concepts in Streaming Graphs", "categories": ["cs.DB"], "comment": null, "summary": "Concept Drift (CD) occurs when a change in a hidden context can induce\nchanges in a target concept. CD is a natural phenomenon in non-stationary\nsettings such as data streams. Understanding, detection, and adaptation to CD\nin streaming data is (i) vital for effective and efficient analytics as\nreliable output depends on adaptation to fresh input, (ii) challenging as it\nrequires efficient operations as well as effective performance evaluations, and\n(iii) impactful as it applies to a variety of use cases and is a crucial\ninitial step for data management systems. Current works are mostly focused on\npassive CD detection as part of supervised adaptation, on independently\ngenerated data instances or graph snapshots, on target concepts as a function\nof data labels, on static data management, and on specific temporal order of\ndata record. These methods do not always work. We revisit CD for the streaming\ngraphs setting and introduce two first-of-its-kind frameworks SGDD and SGDP for\nstreaming graph CD detection and prediction. Both frameworks discern the change\nof generative source. SGDD detects the CDs due to the changes of generative\nparameters with significant delays such that it is difficult to evaluate the\nperformance, while SGDP predicts these CDs between 7374 to 0.19 milliseconds\nahead of their occurrence, without accessing the payloads of data records.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.17702", "pdf": "https://arxiv.org/pdf/2506.17702", "abs": "https://arxiv.org/abs/2506.17702", "authors": ["Stefan Mengel"], "title": "Lower Bounds for Conjunctive Query Evaluation", "categories": ["cs.DB", "cs.CC"], "comment": "paper for the tutorial at PODS 2025", "summary": "In this tutorial, we will survey known results on the complexity of\nconjunctive query evaluation in different settings, ranging from Boolean\nqueries over counting to more complex models like enumeration and direct\naccess. A particular focus will be on showing how different relatively recent\nhypotheses from complexity theory connect to query answering and allow showing\nthat known algorithms in several cases can likely not be improved.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18013", "pdf": "https://arxiv.org/pdf/2506.18013", "abs": "https://arxiv.org/abs/2506.18013", "authors": ["Muhammad Farhan", "Henning Koehler", "Qing Wang"], "title": "Dual-Hierarchy Labelling: Scaling Up Distance Queries on Dynamic Road Networks", "categories": ["cs.DB", "cs.DS"], "comment": null, "summary": "Computing the shortest-path distance between any two given vertices in road\nnetworks is an important problem. A tremendous amount of research has been\nconducted to address this problem, most of which are limited to static road\nnetworks. Since road networks undergo various real-time traffic conditions,\nthere is a pressing need to address this problem for dynamic road networks.\nExisting state-of-the-art methods incrementally maintain an indexing structure\nto reflect dynamic changes on road networks. However, these methods suffer from\neither slow query response time or poor maintenance performance, particularly\nwhen road networks are large. In this work, we propose an efficient solution\n\\emph{Dual-Hierarchy Labelling (DHL)} for distance querying on dynamic road\nnetworks from a novel perspective, which incorporates two hierarchies with\ndifferent but complementary data structures to support efficient query and\nupdate processing. Specifically, our proposed solution is comprised of three\nmain components: \\emph{query hierarchy}, \\emph{update hierarchy}, and\n\\emph{hierarchical labelling}, where \\emph{query hierarchy} enables efficient\nquery answering by exploring only a small subset of vertices in the labels of\ntwo query vertices and \\emph{update hierarchy} supports efficient maintenance\nof distance labelling under edge weight increase or decrease. We further\ndevelop dynamic algorithms to reflect dynamic changes by efficiently\nmaintaining the update hierarchy and hierarchical labelling. We also propose a\nparallel variant of our dynamic algorithms by exploiting labelling structure.\nWe evaluate our methods on 10 large road networks and it shows that our methods\nsignificantly outperform the state-of-the-art methods, i.e., achieving\nconsiderably faster construction and update time, while being consistently 2-4\ntimes faster in terms of query processing and consuming only 10\\%-20\\%\nlabelling space.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18062", "pdf": "https://arxiv.org/pdf/2506.18062", "abs": "https://arxiv.org/abs/2506.18062", "authors": ["Samirasadat Jamalidinan", "Kazem Cheshmi"], "title": "Floating-Point Data Transformation for Lossless Compression", "categories": ["cs.DB", "cs.DC"], "comment": null, "summary": "Floating-point data is widely used across various domains. Depending on the\nrequired precision, each floating-point value can occupy several bytes.\nLossless storage of this information is crucial due to its critical accuracy,\nas seen in applications such as medical imaging and language model weights. In\nthese cases, data size is often significant, making lossless compression\nessential. Previous approaches either treat this data as raw byte streams for\ncompression or fail to leverage all patterns within the dataset. However,\nbecause multiple bytes represent a single value and due to inherent patterns in\nfloating-point representations, some of these bytes are correlated. To leverage\nthis property, we propose a novel data transformation method called Typed Data\nTransformation (\\DTT{}) that groups related bytes together to improve\ncompression. We implemented and tested our approach on various datasets across\nboth CPU and GPU. \\DTT{} achieves a geometric mean compression ratio\nimprovement of 1.16$\\times$ over state-of-the-art compression tools such as\nzstd, while also improving both compression and decompression throughput by\n1.18--3.79$\\times$.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18252", "pdf": "https://arxiv.org/pdf/2506.18252", "abs": "https://arxiv.org/abs/2506.18252", "authors": ["Jinjin Zhao"], "title": "Learning Lineage Constraints for Data Science Operations", "categories": ["cs.DB"], "comment": null, "summary": "Data science workflows often integrate functionalities from a diverse set of\nlibraries and frameworks. Tasks such as debugging require data lineage that\ncrosses library boundaries. The problem is that the way that \"lineage\" is\nrepresented is often intimately tied to particular data models and data\nmanipulation paradigms. Inspired by the use of intermediate representations\n(IRs) in cross-library performance optimizations, this vision paper proposes a\nsimilar architecture for lineage - how do we specify logical lineage across\nlibraries in a common parameterized way? In practice, cross-library workflows\nwill contain both known operations and unknown operations, so a key design of\nXProv to link both materialized lineage graphs of data transformations and the\naforementioned abstracted logical patterns. We further discuss early ideas on\nhow to infer logical patterns when only the materialized graphs are available.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18255", "pdf": "https://arxiv.org/pdf/2506.18255", "abs": "https://arxiv.org/abs/2506.18255", "authors": ["Jinjin Zhao", "Sanjay Krishnan"], "title": "Fast Capture of Cell-Level Provenance in Numpy", "categories": ["cs.DB"], "comment": null, "summary": "Effective provenance tracking enhances reproducibility, governance, and data\nquality in array workflows. However, significant challenges arise in capturing\nthis provenance, including: (1) rapidly evolving APIs, (2) diverse operation\ntypes, and (3) large-scale datasets. To address these challenges, this paper\npresents a prototype annotation system designed for arrays, which captures\ncell-level provenance specifically within the numpy library. With this\nprototype, we explore straightforward memory optimizations that substantially\nreduce annotation latency. We envision this provenance capture approach for\narrays as part of a broader governance system for tracking for structured data\nworkflows and diverse data science applications.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18257", "pdf": "https://arxiv.org/pdf/2506.18257", "abs": "https://arxiv.org/abs/2506.18257", "authors": ["Jinjin Zhao", "Sanjay Krishnan"], "title": "TableVault: Managing Dynamic Data Collections for LLM-Augmented Workflows", "categories": ["cs.DB"], "comment": null, "summary": "Large Language Models (LLMs) have emerged as powerful tools for automating\nand executing complex data tasks. However, their integration into more complex\ndata workflows introduces significant management challenges. In response, we\npresent TableVault - a data management system designed to handle dynamic data\ncollections in LLM-augmented environments. TableVault meets the demands of\nthese workflows by supporting concurrent execution, ensuring reproducibility,\nmaintaining robust data versioning, and enabling composable workflow design. By\nmerging established database methodologies with emerging LLM-driven\nrequirements, TableVault offers a transparent platform that efficiently manages\nboth structured data and associated data artifacts.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18772", "pdf": "https://arxiv.org/pdf/2506.18772", "abs": "https://arxiv.org/abs/2506.18772", "authors": ["Hassan S. Al Khatib", "Subash Neupane", "Sudip Mittal", "Shahram Rahimi", "Nina Marhamati", "Sean Bozorgzad"], "title": "Patient Journey Ontology: Representing Medical Encounters for Enhanced Patient-Centric Applications", "categories": ["cs.DB"], "comment": null, "summary": "The healthcare industry is moving towards a patient-centric paradigm that\nrequires advanced methods for managing and representing patient data. This\npaper presents a Patient Journey Ontology (PJO), a framework that aims to\ncapture the entirety of a patient's healthcare encounters. Utilizing\nontologies, the PJO integrates different patient data sources like medical\nhistories, diagnoses, treatment pathways, and outcomes; it enables semantic\ninteroperability and enhances clinical reasoning. By capturing temporal,\nsequential, and causal relationships between medical encounters, the PJO\nsupports predictive analytics, enabling earlier interventions and optimized\ntreatment plans. The ontology's structure, including its main classes,\nsubclasses, properties, and relationships, as detailed in the paper,\ndemonstrates its ability to provide a holistic view of patient care.\nQuantitative and qualitative evaluations by Subject Matter Experts (SMEs)\ndemonstrate strong capabilities in patient history retrieval, symptom tracking,\nand provider interaction representation, while identifying opportunities for\nenhanced diagnosis-symptom linking. These evaluations reveal the PJO's\nreliability and practical applicability, demonstrating its potential to enhance\npatient outcomes and healthcare efficiency. This work contributes to the\nongoing efforts of knowledge representation in healthcare, offering a reliable\ntool for personalized medicine, patient journey analysis and advancing the\ncapabilities of Generative AI in healthcare applications.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18842", "pdf": "https://arxiv.org/pdf/2506.18842", "abs": "https://arxiv.org/abs/2506.18842", "authors": ["Patrick Beukema", "Henry Herzog", "Yawen Zhang", "Hunter Pitelka", "Favyen Bastani"], "title": "LIGHTHOUSE: Fast and precise distance to shoreline calculations from anywhere on earth", "categories": ["cs.DB", "cs.CV", "cs.LG"], "comment": "8 pages, 7 figures, 1 table, ICML 2025 ML4RS", "summary": "We introduce a new dataset and algorithm for fast and efficient coastal\ndistance calculations from Anywhere on Earth (AoE). Existing global coastal\ndatasets are only available at coarse resolution (e.g. 1-4 km) which limits\ntheir utility. Publicly available satellite imagery combined with computer\nvision enable much higher precision. We provide a global coastline dataset at\n10 meter resolution, a 100+ fold improvement in precision over existing data.\nTo handle the computational challenge of querying at such an increased scale,\nwe introduce a new library: Layered Iterative Geospatial Hierarchical\nTerrain-Oriented Unified Search Engine (Lighthouse). Lighthouse is both\nexceptionally fast and resource-efficient, requiring only 1 CPU and 2 GB of RAM\nto achieve millisecond online inference, making it well suited for real-time\napplications in resource-constrained environments.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.17508", "pdf": "https://arxiv.org/pdf/2506.17508", "abs": "https://arxiv.org/abs/2506.17508", "authors": ["Sajratul Y. Rubaiat", "Syed N. Sakib", "Hasan M. Jamil"], "title": "Mapping the Evolution of Research Contributions using KnoVo", "categories": ["cs.DL", "cs.AI", "cs.DB", "cs.ET", "cs.IR"], "comment": null, "summary": "This paper presents KnoVo (Knowledge Evolution), an intelligent framework\ndesigned for quantifying and analyzing the evolution of research novelty in the\nscientific literature. Moving beyond traditional citation analysis, which\nprimarily measures impact, KnoVo determines a paper's novelty relative to both\nprior and subsequent work within its multilayered citation network. Given a\ntarget paper's abstract, KnoVo utilizes Large Language Models (LLMs) to\ndynamically extract dimensions of comparison (e.g., methodology, application,\ndataset). The target paper is then compared to related publications along these\nsame extracted dimensions. This comparative analysis, inspired by tournament\nselection, yields quantitative novelty scores reflecting the relative\nimprovement, equivalence, or inferiority of the target paper in specific\naspects. By aggregating these scores and visualizing their progression, for\ninstance, through dynamic evolution graphs and comparative radar charts, KnoVo\nfacilitates researchers not only to assess originality and identify similar\nwork, but also to track knowledge evolution along specific research dimensions,\nuncover research gaps, and explore cross-disciplinary connections. We\ndemonstrate these capabilities through a detailed analysis of 20 diverse papers\nfrom multiple scientific fields and report on the performance of various\nopen-source LLMs within the KnoVo framework.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.17613", "pdf": "https://arxiv.org/pdf/2506.17613", "abs": "https://arxiv.org/abs/2506.17613", "authors": ["Ling Li", "Daniel Gibney", "Sharma V. Thankachan", "Solon P. Pissis", "Grigorios Loukides"], "title": "Contextual Pattern Mining and Counting", "categories": ["cs.DS", "cs.DB"], "comment": "27 pages, 15 figures", "summary": "Given a string $P$ of length $m$, a longer string $T$ of length $n>m$, and\ntwo integers $l\\geq 0$ and $r\\geq 0$, the context of $P$ in $T$ is the set of\nall string pairs $(L,R)$, with $|L|=l$ and $|R|=r$, such that the string $LPR$\noccurs in $T$. We introduce two problems related to the notion of context: (1)\nthe Contextual Pattern Mining (CPM) problem, which given $T$, $(m,l,r)$, and an\ninteger $\\tau>0$, asks for outputting the context of each substring $P$ of\nlength $m$ of $T$, provided that the size of the context of $P$ is at least\n$\\tau$; and (2) the Contextual Pattern Counting (CPC) problem, which asks for\npreprocessing $T$ so that the size of the context of a given query string $P$\nof length $m$ can be found efficiently.\n  For CPM, we propose a linear-work algorithm that either uses only internal\nmemory, or a bounded amount of internal memory and external memory, which\nallows much larger datasets to be handled. For CPC, we propose an\n$\\widetilde{\\mathcal{O}}(n)$-space index that can be constructed in\n$\\widetilde{\\mathcal{O}}n)$ time and answers queries in\n$\\mathcal{O}(m)+\\widetilde{\\mathcal{O}}(1)$ time. We further improve the\npractical performance of the CPC index by optimizations that exploit the LZ77\nfactorization of $T$ and an upper bound on the query length. Using\nbillion-letter datasets from different domains, we show that the external\nmemory version of our CPM algorithm can deal with very large datasets using a\nsmall amount of internal memory while its runtime is comparable to that of the\ninternal memory version. Interestingly, we also show that our optimized index\nfor CPC outperforms an approach based on the state of the art for the reporting\nversion of CPC [Navarro, SPIRE 2020] in terms of query time, index size,\nconstruction time, and construction space, often by more than an order of\nmagnitude.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.17977", "pdf": "https://arxiv.org/pdf/2506.17977", "abs": "https://arxiv.org/abs/2506.17977", "authors": ["Tingting Zhu", "Tingyang Chen", "Yinghui Wu", "Arijit Khan", "Xiangyu Ke"], "title": "SliceGX: Layer-wise GNN Explanation with Model-slicing", "categories": ["cs.LG", "cs.DB"], "comment": null, "summary": "Ensuring the trustworthiness of graph neural networks (GNNs) as black-box\nmodels requires effective explanation methods. Existing GNN explanations\ntypically apply input perturbations to identify subgraphs that are responsible\nfor the occurrence of the final output of GNNs. However, such approaches lack\nfiner-grained, layer-wise analysis of how intermediate representations\ncontribute to the final result, capabilities that are crucial for model\ndiagnosis and architecture optimization. This paper introduces SliceGX, a novel\nGNN explanation approach that generates explanations at specific GNN layers in\na progressive manner. Given a GNN M, a set of selected intermediate layers, and\na target layer, SliceGX automatically segments M into layer blocks (\"model\nslice\") and discovers high-quality explanatory subgraphs in each layer block\nthat clarifies the occurrence of output of M at the targeted layer. Although\nfinding such layer-wise explanations is computationally challenging, we develop\nefficient algorithms and optimization techniques that incrementally generate\nand maintain these subgraphs with provable approximation guarantees.\nAdditionally, SliceGX offers a SPARQL-like query interface, providing\ndeclarative access and search capacities for the generated explanations.\nThrough experiments on large real-world graphs and representative GNN\narchitectures, we verify the effectiveness and efficiency of SliceGX, and\nillustrate its practical utility in supporting model debugging.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2506.18499", "pdf": "https://arxiv.org/pdf/2506.18499", "abs": "https://arxiv.org/abs/2506.18499", "authors": ["Alessandra Agostini", "Andrea Maurino", "Blerina Spahiu"], "title": "PuckTrick: A Library for Making Synthetic Data More Realistic", "categories": ["cs.LG", "cs.AI", "cs.DB", "H.4.1; I.2.1"], "comment": "17 pages, 3 figures", "summary": "The increasing reliance on machine learning (ML) models for decision-making\nrequires high-quality training data. However, access to real-world datasets is\noften restricted due to privacy concerns, proprietary restrictions, and\nincomplete data availability. As a result, synthetic data generation (SDG) has\nemerged as a viable alternative, enabling the creation of artificial datasets\nthat preserve the statistical properties of real data while ensuring privacy\ncompliance. Despite its advantages, synthetic data is often overly clean and\nlacks real-world imperfections, such as missing values, noise, outliers, and\nmisclassified labels, which can significantly impact model generalization and\nrobustness. To address this limitation, we introduce Pucktrick, a Python\nlibrary designed to systematically contaminate synthetic datasets by\nintroducing controlled errors. The library supports multiple error types,\nincluding missing data, noisy values, outliers, label misclassification,\nduplication, and class imbalance, offering a structured approach to evaluating\nML model resilience under real-world data imperfections. Pucktrick provides two\ncontamination modes: one for injecting errors into clean datasets and another\nfor further corrupting already contaminated datasets. Through extensive\nexperiments on real-world financial datasets, we evaluate the impact of\nsystematic data contamination on model performance. Our findings demonstrate\nthat ML models trained on contaminated synthetic data outperform those trained\non purely synthetic, error-free data, particularly for tree-based and linear\nmodels such as SVMs and Extra Trees.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
