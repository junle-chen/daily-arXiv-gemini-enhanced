{"id": "2506.11298", "pdf": "https://arxiv.org/pdf/2506.11298", "abs": "https://arxiv.org/abs/2506.11298", "authors": ["Piotr Sowinski", "Karolina Bogacka", "Anastasiya Danilenka", "Nikita Kozlov"], "title": "Jelly: a fast and convenient RDF serialization format", "categories": ["cs.DB", "cs.NI"], "comment": null, "summary": "Existing RDF serialization formats such as Turtle, N-Triples, and JSON-LD are\nwidely used for communication and storage in knowledge graph and Semantic Web\napplications. However, they suffer from limitations in performance, compression\nratio, and lack of native support for RDF streams. To address these\nshortcomings, we introduce Jelly, a fast and convenient binary serialization\nformat for RDF data that supports both batch and streaming use cases. Jelly is\ndesigned to maximize serialization throughput, reduce file size with\nlightweight streaming compression, and minimize compute resource usage. Built\non Protocol Buffers, Jelly is easy to integrate with modern programming\nlanguages and RDF libraries. To maximize reusability, Jelly has an open\nprotocol specification, open-source implementations in Java and Python\nintegrated with popular RDF libraries, and a versatile command-line tool. To\nillustrate its usefulness, we outline concrete use cases where Jelly can\nprovide tangible benefits. By combining practical usability with\nstate-of-the-art efficiency, Jelly is an important contribution to the Semantic\nWeb tool stack."}
{"id": "2506.11541", "pdf": "https://arxiv.org/pdf/2506.11541", "abs": "https://arxiv.org/abs/2506.11541", "authors": ["Aaron K\u00fcsters", "Wil M. P. van der Aalst"], "title": "OCPQ: Object-Centric Process Querying & Constraints", "categories": ["cs.DB"], "comment": null, "summary": "Process querying is used to extract information and insights from process\nexecution data. Similarly, process constraints can be checked against input\ndata, yielding information on which process instances violate them.\nTraditionally, such process mining techniques use case-centric event data as\ninput. However, with the uptake of Object-Centric Process Mining (OCPM),\nexisting querying and constraint checking techniques are no longer applicable.\nObject-Centric Event Data (OCED) removes the requirement to pick a single case\nnotion (i.e., requiring that events belong to exactly one case) and can thus\nrepresent many real-life processes much more accurately. In this paper, we\npresent a novel highly-expressive approach for object-centric process querying,\ncalled OCPQ. It supports a wide variety of applications, including OCED-based\nconstraint checking and filtering. The visual representation of nested queries\nin OCPQ allows users to intuitively read and create queries and constraints. We\nimplemented our approach using (1) a high-performance execution engine backend\nand (2) an easy-to-use editor frontend. Additionally, we evaluated our approach\non a real-life dataset, showing the lack in expressiveness of prior work and\nruntime performance significantly better than the general querying solutions\nSQLite and Neo4j, as well as comparable to the performance-focused DuckDB."}
{"id": "2506.11870", "pdf": "https://arxiv.org/pdf/2506.11870", "abs": "https://arxiv.org/abs/2506.11870", "authors": ["Ce Lyu", "Minghao Zhao", "Yanhao Wang", "Liang Jie"], "title": "LLM-based Dynamic Differential Testing for Database Connectors with Reinforcement Learning-Guided Prompt Selection", "categories": ["cs.DB", "68N99", "H.2.4; D.2.5"], "comment": "5 pages", "summary": "Database connectors are critical components enabling applications to interact\nwith underlying database management systems (DBMS), yet their security\nvulnerabilities often remain overlooked. Unlike traditional software defects,\nconnector vulnerabilities exhibit subtle behavioral patterns and are inherently\nchallenging to detect. Besides, nonstandardized implementation of connectors\nleaves potential risks (a.k.a. unsafe implementations) but is more elusive. As\na result, traditional fuzzing methods are incapable of finding such\nvulnerabilities. Even for LLM-enable test case generation, due to a lack of\ndomain knowledge, they are also incapable of generating test cases that invoke\nall interface and internal logic of connectors. In this paper, we propose\nreinforcement learning (RL)-guided LLM test-case generation for database\nconnector testing. Specifically, to equip the LLM with sufficient and\nappropriate domain knowledge, a parameterized prompt template is composed which\ncan be utilized to generate numerous prompts. Test cases are generated via LLM\nwith a prompt, and are dynamically evaluated through differential testing\nacross multiple connectors. The testing is iteratively conducted, with each\nround RL is adopted to select optimal prompt based on prior-round behavioral\nfeedback, so as to maximize control flow coverage. We implement aforementioned\nmethodology in a practical tool and evaluate it on two widely used JDBC\nconnectors: MySQL Connector/J and OceanBase Connector/J. In total, we reported\n16 bugs, among them 10 are officially confirmed and the rest are acknowledged\nas unsafe implementations."}
{"id": "2506.11010", "pdf": "https://arxiv.org/pdf/2506.11010", "abs": "https://arxiv.org/abs/2506.11010", "authors": ["Emilio Porcu", "Roy El Moukari", "Laurent Najman", "Francisco Herrera", "Horst Simon"], "title": "Data Science: a Natural Ecosystem", "categories": ["cs.LG", "cs.AI", "cs.DB", "stat.ML"], "comment": null, "summary": "This manuscript provides a holistic (data-centric) view of what we term\nessential data science, as a natural ecosystem with challenges and missions\nstemming from the data universe with its multiple combinations of the 5D\ncomplexities (data structure, domain, cardinality, causality, and ethics) with\nthe phases of the data life cycle. Data agents perform tasks driven by specific\ngoals. The data scientist is an abstract entity that comes from the logical\norganization of data agents with their actions. Data scientists face challenges\nthat are defined according to the missions. We define specific\ndiscipline-induced data science, which in turn allows for the definition of\npan-data science, a natural ecosystem that integrates specific disciplines with\nthe essential data science. We semantically split the essential data science\ninto computational, and foundational. We claim that there is a serious threat\nof divergence between computational and foundational data science. Especially,\nif no approach is taken to rate whether a data universe discovery should be\nuseful or not. We suggest that rigorous approaches to measure the usefulness of\ndata universe discoveries might mitigate such a divergence."}
{"id": "2506.11986", "pdf": "https://arxiv.org/pdf/2506.11986", "abs": "https://arxiv.org/abs/2506.11986", "authors": ["Wuzhenghong Wen", "Su Pan", "yuwei Sun"], "title": "Schema-R1: A reasoning training approach for schema linking in Text-to-SQL Task", "categories": ["cs.AI", "cs.CL", "cs.DB"], "comment": "11 pages, 3 figures, conference", "summary": "Schema linking is a critical step in Text-to-SQL task, aiming to accurately\npredict the table names and column names required for the SQL query based on\nthe given question. However, current fine-tuning approaches for schema linking\nmodels employ a rote-learning paradigm, excessively optimizing for ground truth\nschema linking outcomes while compromising reasoning ability. This limitation\narises because of the difficulty in acquiring a high-quality reasoning sample\nfor downstream tasks. To address this, we propose Schema-R1, a reasoning schema\nlinking model trained using reinforcement learning. Specifically, Schema-R1\nconsists of three key steps: constructing small batches of high-quality\nreasoning samples, supervised fine-tuning for cold-start initialization, and\nrule-based reinforcement learning training. The final results demonstrate that\nour method effectively enhances the reasoning ability of the schema linking\nmodel, achieving a 10\\% improvement in filter accuracy compared to the existing\nmethod. Our code is available at https://github.com/hongWin/Schema-R1/."}
