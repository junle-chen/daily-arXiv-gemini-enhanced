# 每日 ArXiv 轨迹预测与大模型摘要速递: 2025-11-20

## 目录

- [cs.DB (8)](#cs-db)

## cs.DB [cs.DB]
### [1] [SQL-to-Text Generation with Weighted-AST Few-Shot Prompting](https://arxiv.org/abs/2511.13907)
*Sriom Chakrabarti, Chuangtao Ma, Arijit Khan, Sebastian Link*

Main category: cs.DB

TL;DR: 该论文提出了一种基于加权抽象语法树（AST）检索和提示的SQL-to-Text生成方法，以提高生成文本的语义准确性。


<details>
  <summary>Details</summary>
Motivation: 现有SQL-to-Text方法难以保证生成文本与SQL查询的精确语义一致性，尤其是在存在多种正确表达的情况下。

Method: 提出一种加权AST检索与提示的架构，该架构使用基于AST的相似性度量检索语义相关的示例作为少样本提示，其中AST的特征权重是经过学习的。

Result: 在Spider、SParC和CoSQL三个基准数据集上的实验表明，该方法在执行准确率（EX）上优于当前基线高达+17.24%，在精确匹配（EM）上表现更优，并且在人工评估中提供更一致的语义保真度，同时保持了有竞争力的运行时间性能。

Conclusion: 加权AST提示是一种可扩展且有效的方法，可以从结构化数据库查询中推导出自然语言解释。

Abstract: SQL-to-Text生成旨在将结构化的SQL查询翻译成自然语言描述，从而方便非技术用户理解复杂的数据库操作。虽然大型语言模型（LLM）最近已经展示出很有希望的结果，但当前的方法通常无法保持SQL查询的精确语义，尤其是在存在多种可能的正确措辞时。为了解决这个问题，我们的工作提出了一种加权AST检索与提示的架构，该架构集成了结构化查询表示和LLM提示。该方法使用基于抽象语法树（AST）的相似性度量来检索语义相关的示例作为少样本提示，其中AST具有学习的特征权重。我们的结构感知提示技术确保生成的描述既流畅又忠实于原始查询逻辑。在Spider、SParC和CoSQL三个基准数据集上的大量实验表明，我们的方法在执行准确率（EX）上优于当前基线高达+17.24%，在精确匹配（EM）上表现更优，并且在人工评估中提供更一致的语义保真度，同时保持了有竞争力的运行时间性能。这些结果表明，加权AST提示是一种可扩展且有效的方法，可以从结构化数据库查询中推导出自然语言解释。

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.13907) | **Categories:** cs.DB

---

### [2] [Fast Verification of Strong Database Isolation (Extended Version)](https://arxiv.org/abs/2511.14067)
*Zhiheng Cai, Si Liu, Hengfeng Wei, Yuxing Chen, Anqun Pan*

Main category: cs.DB

TL;DR: 本文提出了一种名为VeriStrong的高效验证器，用于验证数据库的强隔离性，它通过新颖的超多图形式化方法，能够有效地捕获事务间的确定和不确定依赖关系，并针对数据库工作负载优化了SMT求解，从而在各种基准测试中显著优于现有验证器。


<details>
  <summary>Details</summary>
Motivation: 在现代数据库中，强隔离保证（如可串行化和快照隔离）对于维护数据一致性和完整性至关重要。验证数据库是否坚持其声明的保证变得越来越重要，因为这些保证构成了供应商与其用户之间的合同。然而，这项任务具有挑战性，尤其是在黑盒设置中，在这种设置中，只有可观察的系统行为可用，并且通常涉及事务之间不确定的依赖关系。

Method: 本文提出了一种名为VeriStrong的快速验证器，用于验证强数据库隔离。它的核心是一种新颖的形式化方法，称为超多图，它可以紧凑地捕获数据库执行中确定和不确定的事务依赖关系。利用这种形式化方法，我们开发了用于验证可串行性和快照隔离的可靠且完整的编码。为了实现高效率，VeriStrong根据数据库工作负载的特性定制了SMT求解，这与先前的通用方法不同。

Result: 在各种基准测试中进行的广泛评估表明，VeriStrong不仅在它支持的工作负载上显著优于最先进的验证器，而且还可以扩展到超出其范围的大型通用工作负载，同时保持检测隔离异常的高精度。

Conclusion: 本文提出了一种名为VeriStrong的高效验证器，用于验证数据库的强隔离性，实验结果表明VeriStrong在各种基准测试中显著优于现有验证器，并且可以扩展到大型通用工作负载，同时保持检测隔离异常的高精度。

Abstract: 现代数据库中，诸如可串行化和快照隔离等强隔离性保证对于维护数据的一致性和完整性至关重要。验证数据库是否遵守其声明的保证变得越来越重要，因为这些保证构成了供应商和用户之间的约定。然而，这项任务极具挑战性，尤其是在黑盒环境中，因为在这种环境中，我们只能观察到系统的行为，且事务间的依赖关系往往不确定。在本文中，我们提出了一种名为VeriStrong的快速验证器，用于验证数据库的强隔离性。其核心是一种新颖的形式化方法，称为超多图，它可以紧凑地捕获数据库执行过程中确定和不确定的事务依赖关系。基于此，我们开发了可靠且完整的编码，用于验证可串行化和快照隔离。为了实现高效率，VeriStrong 针对数据库工作负载的特性定制了 SMT 求解，这与以往的通用方法不同。我们在各种基准测试中进行了广泛的评估，结果表明，VeriStrong 不仅在它所支持的工作负载上显著优于最先进的验证器，而且可以扩展到超出它们能力范围的大型通用工作负载，同时保持检测隔离异常的高精度。

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14067) | **Categories:** cs.DB

---

### [3] [Chipmink: Efficient Delta Identification for Massive Object Graph](https://arxiv.org/abs/2511.14162)
*Supawit Chockchowwat, Sumay Thakurdesai, Zhaoheng Li, Matthew Krafczyk, Yongjoo Park*

Main category: cs.DB

TL;DR: Chipmink 通过将对象划分为 pod 来实现高效的部分持久化，从而显著减少存储空间和加速持久化过程。


<details>
  <summary>Details</summary>
Motivation: 现有的对象持久化机制依赖于完全快照，导致时间和存储上的低效，并且数据科学系统缺乏跟踪脏对象的集中式缓冲管理器。

Method: 提出了一种基于图的对象存储 Chipmink，它将对象划分为 pod，并基于对象大小和引用结构最小化预期持久化成本。

Result: 实验表明，Chipmink 支持依赖于共享内存、GPU 和远程对象的库，并且在真实世界的 notebook 和脚本中，Chipmink 的存储空间最多减少了 36.5 倍，持久化速度提高了 12.4 倍。

Conclusion: Chipmink 通过动态地将对象分组到 pod 中，有效地隔离了脏对象，实现了高效的部分持久化。

Abstract: 现代数据科学工具依赖于庞大且不断演化的对象图，这些对象图表示结构化数据、模型、图表等。持久化这些对象至关重要，不仅可以增强系统应对意外故障的鲁棒性，还可以支持通过版本控制进行连续的、非线性的数据探索。现有的对象持久化机制（例如 Pickle、Dill）依赖于完全快照，经常在执行和探索过程中冗余地存储未更改的对象，从而导致时间和存储上的显著低效。与数据库管理系统（DBMS）不同，数据科学系统缺乏跟踪脏对象的集中式缓冲管理器。更糟糕的是，对象状态跨越各种位置，例如内存堆、共享内存、GPU 和远程机器，这使得脏对象识别从根本上更具挑战性。在这项工作中，我们提出了一种基于图的对象存储，名为 Chipmink，它就像集中式缓冲管理器。与 DBMS 中的静态页面不同，Chipmink 中的持久化单元是由将对象划分为适当的子组（称为 pod）动态诱导的，从而根据对象大小和引用结构最小化预期的持久化成本。这些 pod 有效地隔离了脏对象，从而实现高效的部分持久化。我们的实验表明，Chipmink 具有通用性，支持依赖于共享内存、GPU 和远程对象的库。此外，在真实世界的 notebook 和脚本中，Chipmink 的存储空间最多减少了 36.5 倍，持久化速度提高了 12.4 倍。

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14162) | **Categories:** cs.DB

---

### [4] [Gradient-Based Join Ordering](https://arxiv.org/abs/2511.14482)
*Tim Schwabe, Maribel Acosta*

Main category: cs.DB

TL;DR: 达到API配额限制，请明天再试


<details>
  <summary>Details</summary>
Motivation: Error: API quota exceeded

Method: Error: API quota exceeded

Result: Error: API quota exceeded

Conclusion: 请联系管理员或等待明天API配额重置。

Abstract: Join ordering is the NP-hard problem of selecting the most efficient sequence in which to evaluate joins (conjunctive, binary operators) in a database query. As the performance of query execution critically depends on this choice, join ordering lies at the core of query optimization. Traditional approaches cast this problem as a discrete combinatorial search over binary trees guided by a cost model, but they often suffer from high computational complexity and limited scalability. We show that, when the cost model is differentiable, the query plans can be continuously relaxed into a soft adjacency matrix representing a superposition of plans. This continuous relaxation, together with a Gumbel-Softmax parameterization of the adjacency matrix and differentiable constraints enforcing plan validity, enables gradient-based search for plans within this relaxed space. Using a learned Graph Neural Network as the cost model, we demonstrate that this gradient-based approach can find comparable and even lower-cost plans compared to traditional discrete local search methods on two different graph datasets. Furthermore, we empirically show that the runtime of this approach scales linearly with query size, in contrast to quadratic or exponential runtimes of classical approaches. We believe this first step towards gradient-based join ordering can lead to more effective and efficient query optimizers in the future.

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14482) | **Categories:** cs.DB, cs.LG

---

### [5] [Overview and Prospects of Using Integer Surrogate Keys for Data Warehouse Performance Optimization](https://arxiv.org/abs/2511.14502)
*Sviatoslav Stumpf, Vladislav Povyshev*

Main category: cs.DB

TL;DR: 达到API配额限制，请明天再试


<details>
  <summary>Details</summary>
Motivation: Error: API quota exceeded

Method: Error: API quota exceeded

Result: Error: API quota exceeded

Conclusion: 请联系管理员或等待明天API配额重置。

Abstract: The aim of this paper is to examine and demonstrate how integer-based datetime labels (integer surrogate keys for time) can optimize data-warehouse and time-series performance, proposing practical formats and algorithms and validating their efficiency on real-world workloads. It is shown that replacing standard DATE and TIMESTAMP types with 32- and 64-bit integer formats reduces storage requirements by 30-60 percent and speeds up query execution by 25-40 percent. The paper presents indexing, aggregation, compression, and batching algorithms demonstrating up to an eightfold increase in throughput. Practical examples from finance, telecommunications, IoT, and scientific research confirm the efficiency and versatility of the proposed approach.

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14502) | **Categories:** cs.DB, cs.DC

---

### [6] [Scalable Enforcement of Fine Grained Access Control Policies in Relational Database Management Systems](https://arxiv.org/abs/2511.14629)
*Anadi Shakya, Primal Pappachan, David Maier, Roberto Yus, Sharad Mehrotra, Johann-Christoph Freytag*

Main category: cs.DB

TL;DR: 达到API配额限制，请明天再试


<details>
  <summary>Details</summary>
Motivation: Error: API quota exceeded

Method: Error: API quota exceeded

Result: Error: API quota exceeded

Conclusion: 请联系管理员或等待明天API配额重置。

Abstract: The proliferation of smart technologies and evolving privacy regulations such as the GDPR and CPRA has increased the need to manage fine-grained access control (FGAC) policies in database management systems (DBMSs). Existing approaches to enforcing FGAC policies do not scale to thousands of policies, leading to degraded query performance and reduced system effectiveness. We present Sieve, a middleware for relational DBMSs that combines query rewriting and caching to optimize FGAC policy enforcement. Sieve rewrites a query with guarded expressions that group and filter policies and can efficiently use indexes in the DBMS. It also integrates a caching mechanism with an effective replacement strategy and a refresh mechanism to adapt to dynamic workloads. Experiments on two DBMSs with real and synthetic datasets show that Sieve scales to large datasets and policy corpora, maintaining low query latency and system load and improving policy evaluation performance by between 2x and 10x on workloads with 200 to 1,200 policies. The caching extension further improves query performance by between 6 and 22 percent under dynamic workloads, especially with larger cache sizes. These results highlight Sieve's applicability for real-time access control in smart environments and its support for efficient, scalable management of user preferences and privacy policies.

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14629) | **Categories:** cs.DB

---

### [7] [Natural Language Interfaces for Databases: What Do Users Think?](https://arxiv.org/abs/2511.14718)
*Panos Ipeirotis, Haotian Zheng*

Main category: cs.DB

TL;DR: 达到API配额限制，请明天再试


<details>
  <summary>Details</summary>
Motivation: Error: API quota exceeded

Method: Error: API quota exceeded

Result: Error: API quota exceeded

Conclusion: 请联系管理员或等待明天API配额重置。

Abstract: Natural Language Interfaces for Databases (NLIDBs) aim to make database querying accessible by allowing users to ask questions in everyday language rather than using formal SQL queries. Despite significant advancements in translation accuracy, critical usability challenges, such as user frustration, query refinement strategies, and error recovery, remain underexplored. To investigate these usability dimensions, we conducted a mixed-method user study comparing SQL-LLM, a state-of-the-art NL2SQL system, with Snowflake, a traditional SQL analytics platform. Our controlled evaluation involved 20 participants completing realistic database querying tasks across 12 queries each. Results show that SQL-LLM significantly reduced query completion times by 10 to 30 percent (mean: 418 s vs. 629 s, p = 0.036) and improved overall accuracy from 50 to 75 percent (p = 0.002). Additionally, participants using SQL-LLM exhibited fewer query reformulations, recovered from errors 30 to 40 seconds faster, and reported lower frustration levels compared to Snowflake users. Behavioral analysis revealed that SQL-LLM encouraged structured, schema-first querying strategies, enhancing user confidence and efficiency, particularly for complex queries. These findings underscore the practical significance of well-designed, user-friendly NLIDBs in business analytics settings, emphasizing the critical role of usability alongside technical accuracy in real-world deployments.

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14718) | **Categories:** cs.DB, cs.HC

---

### [8] [Cloud-Native Vector Search: A Comprehensive Performance Analysis](https://arxiv.org/abs/2511.14748)
*Zhaoheng Li, Wei Ding, Silu Huang, Zikang Wang, Yuanjin Lin, Ke Wu, Yongjoo Park, Jianjun Chen*

Main category: cs.DB

TL;DR: 达到API配额限制，请明天再试


<details>
  <summary>Details</summary>
Motivation: Error: API quota exceeded

Method: Error: API quota exceeded

Result: Error: API quota exceeded

Conclusion: 请联系管理员或等待明天API配额重置。

Abstract: Vector search has been widely employed in recommender system and retrieval-augmented-generation pipelines, commonly performed with vector indexes to efficiently find similar items in large datasets. Recent growths in both data and task complexity have motivated placing vector indexes onto remote storage -- cloud-native vector search, which cloud providers have recently introduced services for. Yet, despite varying workload characteristics and various available vector index forms, providers default to using cluster-based indexes, which on paper do adapt well to differences between disk and cloud-based environment: their fetch granularities and lack of notable intra-query dependencies aligns with the large optimal fetch sizes and minimizes costly round-trips (i.e., as opposed to graph-based indexes) to remote storage, respectively.   This paper systematically studies cloud-native vector search: What and how should indexes be built and used for on-cloud vector search? We analyze bottlenecks of two common index classes, cluster and graph indexes, on remote storage, and show that despite current standardized adoption of cluster indexes on the cloud, graph indexes are favored in workloads requiring high concurrency and recall, or operating on high-dimensional data or large datatypes. We further find that on-cloud search demands significantly different indexing and search parameterizations versus on-disk search for optimal performance. Finally, we incorporate existing cloud-based caching setups into vector search and find that certain index optimizations work against caching, and study how this can be mitigated to maximize gains under various available cache sizes.

</details>

[**[PDF]**](https://arxiv.org/pdf/2511.14748) | **Categories:** cs.DB

---
