{"id": "2510.06414", "pdf": "https://arxiv.org/pdf/2510.06414", "abs": "https://arxiv.org/abs/2510.06414", "authors": ["Abdur Rehman Anwar Qureshi", "Adrian Rebmann", "Timotheus Kampik", "Matthias Weidlich", "Mathias Weske"], "title": "Bridging Imperative Process Models and Process Data Queries-Translation and Relaxation", "categories": ["cs.DB", "cs.SE"], "comment": null, "summary": "Business process management is increasingly practiced using data-driven\napproaches. Still, classical imperative process models, which are typically\nformalized using Petri nets, are not straightforwardly applicable to the\nrelational databases that contain much of the available structured process\nexecution data. This creates a gap between the traditional world of process\nmodeling and recent developments around data-driven process analysis,\nultimately leading to the under-utilization of often readily available process\nmodels. In this paper, we close this gap by providing an approach for\ntranslating imperative models into relaxed process data queries, specifically\nSQL queries executable on relational databases, for conformance checking. Our\nresults show the continued relevance of imperative process models to\ndata-driven process management, as well as the importance of behavioral\nfootprints and other declarative approaches for integrating model-based and\ndata-driven process management.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.06663", "pdf": "https://arxiv.org/pdf/2510.06663", "abs": "https://arxiv.org/abs/2510.06663", "authors": ["Qiuyang Mang", "Runyuan He", "Suyang Zhong", "Xiaoxuan Liu", "Huanchen Zhang", "Alvin Cheung"], "title": "Automated Discovery of Test Oracles for Database Management Systems Using LLMs", "categories": ["cs.DB", "cs.PL", "cs.SE"], "comment": null, "summary": "Since 2020, automated testing for Database Management Systems (DBMSs) has\nflourished, uncovering hundreds of bugs in widely-used systems. A cornerstone\nof these techniques is test oracle, which typically implements a mechanism to\ngenerate equivalent query pairs, thereby identifying bugs by checking the\nconsistency between their results. However, while applying these oracles can be\nautomated, their design remains a fundamentally manual endeavor. This paper\nexplores the use of large language models (LLMs) to automate the discovery and\ninstantiation of test oracles, addressing a long-standing bottleneck towards\nfully automated DBMS testing. Although LLMs demonstrate impressive creativity,\nthey are prone to hallucinations that can produce numerous false positive bug\nreports. Furthermore, their significant monetary cost and latency mean that LLM\ninvocations should be limited to ensure that bug detection is efficient and\neconomical.\n  To this end, we introduce Argus, a novel framework built upon the core\nconcept of the Constrained Abstract Query - a SQL skeleton containing\nplaceholders and their associated instantiation conditions (e.g., requiring a\nplaceholder to be filled by a boolean column). Argus uses LLMs to generate\npairs of these skeletons that are asserted to be semantically equivalent. This\nequivalence is then formally proven using a SQL equivalence solver to ensure\nsoundness. Finally, the placeholders within the verified skeletons are\ninstantiated with concrete, reusable SQL snippets that are also synthesized by\nLLMs to efficiently produce complex test cases. We implemented Argus and\nevaluated it on five extensively tested DBMSs, discovering 40 previously\nunknown bugs, 35 of which are logic bugs, with 36 confirmed and 26 already\nfixed by the developers.", "AI": {"tldr": "\u672c\u6587\u63d0\u51fa\u4e86\u4e00\u79cd\u540d\u4e3aArgus\u7684\u65b0\u6846\u67b6\uff0c\u8be5\u6846\u67b6\u5229\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u81ea\u52a8\u53d1\u73b0\u548c\u5b9e\u4f8b\u5316\u6570\u636e\u5e93\u7ba1\u7406\u7cfb\u7edf\uff08DBMS\uff09\u7684\u6d4b\u8bd5\u9884\u8a00\uff0c\u4ece\u800c\u53d1\u73b0\u65b0\u7684bug\u3002", "motivation": "\u73b0\u6709\u7684\u6570\u636e\u5e93\u7ba1\u7406\u7cfb\u7edf\uff08DBMS\uff09\u7684\u81ea\u52a8\u6d4b\u8bd5\u6280\u672f\u4f9d\u8d56\u4e8e\u624b\u52a8\u8bbe\u8ba1\u7684\u6d4b\u8bd5\u9884\u8a00\uff0c\u6548\u7387\u4f4e\u4e14\u6210\u672c\u9ad8\u3002", "method": "Argus\u6846\u67b6\u57fa\u4e8e\u7ea6\u675f\u62bd\u8c61\u67e5\u8be2\u7684\u6982\u5ff5\uff0c\u4f7f\u7528LLM\u751f\u6210\u67e5\u8be2\u9aa8\u67b6\u5bf9\uff0c\u5e76\u901a\u8fc7SQL\u7b49\u4ef7\u6c42\u89e3\u5668\u9a8c\u8bc1\u5176\u7b49\u4ef7\u6027\uff0c\u6700\u540e\u4f7f\u7528LLM\u751f\u6210\u5177\u4f53\u7684SQL\u4ee3\u7801\u7247\u6bb5\u6765\u5b9e\u4f8b\u5316\u8fd9\u4e9b\u9aa8\u67b6\u3002", "result": "Argus\u5728\u4e94\u4e2a\u5e7f\u6cdb\u6d4b\u8bd5\u7684DBMS\u4e0a\u53d1\u73b0\u4e8640\u4e2a\u4ee5\u524d\u672a\u77e5\u7684bug\uff0c\u5176\u4e2d35\u4e2a\u662f\u903b\u8f91\u9519\u8bef\uff0c36\u4e2a\u5df2\u786e\u8ba4\uff0c26\u4e2a\u5df2\u88ab\u5f00\u53d1\u4eba\u5458\u4fee\u590d\u3002", "conclusion": "Argus\u6846\u67b6\u80fd\u591f\u6709\u6548\u5730\u5229\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b\u81ea\u52a8\u751f\u6210\u9ad8\u8d28\u91cf\u7684\u6570\u636e\u5e93\u6d4b\u8bd5\u9884\u8a00\uff0c\u663e\u8457\u63d0\u9ad8\u4e86DBMS\u6d4b\u8bd5\u7684\u6548\u7387\u548cbug\u53d1\u73b0\u80fd\u529b\u3002", "summary_zh": "\u81ea2020\u5e74\u4ee5\u6765\uff0c\u6570\u636e\u5e93\u7ba1\u7406\u7cfb\u7edf\uff08DBMS\uff09\u7684\u81ea\u52a8\u6d4b\u8bd5\u84ec\u52c3\u53d1\u5c55\uff0c\u63ed\u793a\u4e86\u5e7f\u6cdb\u4f7f\u7528\u7684\u7cfb\u7edf\u4e2d\u7684\u6570\u767e\u4e2a\u9519\u8bef\u3002\u8fd9\u4e9b\u6280\u672f\u7684\u57fa\u77f3\u662f\u6d4b\u8bd5\u9884\u8a00\uff0c\u5b83\u901a\u5e38\u5b9e\u73b0\u4e00\u79cd\u751f\u6210\u7b49\u6548\u67e5\u8be2\u5bf9\u7684\u673a\u5236\uff0c\u4ece\u800c\u901a\u8fc7\u68c0\u67e5\u5176\u7ed3\u679c\u4e4b\u95f4\u7684\u4e00\u81f4\u6027\u6765\u8bc6\u522b\u9519\u8bef\u3002\u7136\u800c\uff0c\u867d\u7136\u5e94\u7528\u8fd9\u4e9b\u9884\u8a00\u53ef\u4ee5\u81ea\u52a8\u5316\uff0c\u4f46\u5b83\u4eec\u7684\u8bbe\u8ba1\u4ecd\u7136\u662f\u4e00\u9879\u6839\u672c\u4e0a\u662f\u624b\u52a8\u7684\u5de5\u4f5c\u3002\u672c\u6587\u63a2\u8ba8\u4e86\u4f7f\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b\uff08LLM\uff09\u6765\u81ea\u52a8\u5316\u6d4b\u8bd5\u9884\u8a00\u7684\u53d1\u73b0\u548c\u5b9e\u4f8b\u5316\uff0c\u4ece\u800c\u89e3\u51b3\u4e86\u4e00\u4e2a\u957f\u671f\u5b58\u5728\u7684\u5b8c\u5168\u81ea\u52a8\u5316DBMS\u6d4b\u8bd5\u7684\u74f6\u9888\u3002\u867d\u7136LLM\u8868\u73b0\u51fa\u4ee4\u4eba\u5370\u8c61\u6df1\u523b\u7684\u521b\u9020\u529b\uff0c\u4f46\u5b83\u4eec\u5bb9\u6613\u4ea7\u751f\u5e7b\u89c9\uff0c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u5927\u91cf\u8bef\u62a5\u3002\u6b64\u5916\uff0c\u5b83\u4eec\u7684\u9ad8\u6602\u7684\u8d27\u5e01\u6210\u672c\u548c\u5ef6\u8fdf\u610f\u5473\u7740LLM\u7684\u8c03\u7528\u5e94\u8be5\u53d7\u5230\u9650\u5236\uff0c\u4ee5\u786e\u4fddbug\u68c0\u6d4b\u662f\u9ad8\u6548\u548c\u7ecf\u6d4e\u7684\u3002\u4e3a\u6b64\uff0c\u6211\u4eec\u4ecb\u7ecdArgus\uff0c\u8fd9\u662f\u4e00\u4e2a\u5efa\u7acb\u5728\u7ea6\u675f\u62bd\u8c61\u67e5\u8be2\u6838\u5fc3\u6982\u5ff5\u4e4b\u4e0a\u7684\u65b0\u9896\u6846\u67b6\u2014\u2014\u4e00\u4e2a\u5305\u542b\u5360\u4f4d\u7b26\u53ca\u5176\u76f8\u5173\u5b9e\u4f8b\u5316\u6761\u4ef6\uff08\u4f8b\u5982\uff0c\u8981\u6c42\u5360\u4f4d\u7b26\u7531\u5e03\u5c14\u5217\u586b\u5145\uff09\u7684SQL\u9aa8\u67b6\u3002Argus\u4f7f\u7528LLM\u751f\u6210\u6210\u5bf9\u7684\u88ab\u65ad\u8a00\u4e3a\u8bed\u4e49\u7b49\u4ef7\u7684\u9aa8\u67b6\u3002\u7136\u540e\uff0c\u4f7f\u7528SQL\u7b49\u4ef7\u6c42\u89e3\u5668\u6b63\u5f0f\u8bc1\u660e\u8fd9\u79cd\u7b49\u4ef7\u6027\uff0c\u4ee5\u786e\u4fdd\u53ef\u9760\u6027\u3002\u6700\u540e\uff0c\u7ecf\u8fc7\u9a8c\u8bc1\u7684\u9aa8\u67b6\u4e2d\u7684\u5360\u4f4d\u7b26\u88ab\u5177\u4f53\u7684\u3001\u53ef\u91cd\u7528\u7684SQL\u4ee3\u7801\u6bb5\u5b9e\u4f8b\u5316\uff0c\u8fd9\u4e9b\u4ee3\u7801\u6bb5\u4e5f\u7531LLM\u5408\u6210\uff0c\u4ee5\u6709\u6548\u5730\u751f\u6210\u590d\u6742\u7684\u6d4b\u8bd5\u7528\u4f8b\u3002\u6211\u4eec\u5b9e\u73b0\u4e86Argus\uff0c\u5e76\u5728\u4e94\u4e2a\u7ecf\u8fc7\u5e7f\u6cdb\u6d4b\u8bd5\u7684DBMS\u4e0a\u5bf9\u5176\u8fdb\u884c\u4e86\u8bc4\u4f30\uff0c\u53d1\u73b0\u4e8640\u4e2a\u4ee5\u524d\u672a\u77e5\u7684\u9519\u8bef\uff0c\u5176\u4e2d35\u4e2a\u662f\u903b\u8f91\u9519\u8bef\uff0c\u5176\u4e2d36\u4e2a\u5df2\u786e\u8ba4\uff0c26\u4e2a\u5df2\u88ab\u5f00\u53d1\u4eba\u5458\u4fee\u590d\u3002"}}
{"id": "2510.06980", "pdf": "https://arxiv.org/pdf/2510.06980", "abs": "https://arxiv.org/abs/2510.06980", "authors": ["Xinyi Gao", "Jingxi Zhang", "Lijian Chen", "Tong Chen", "Lizhen Cui", "Hongzhi Yin"], "title": "Relational Database Distillation: From Structured Tables to Condensed Graph Data", "categories": ["cs.DB", "cs.LG"], "comment": null, "summary": "Relational databases (RDBs) underpin the majority of global data management\nsystems, where information is structured into multiple interdependent tables.\nTo effectively use the knowledge within RDBs for predictive tasks, recent\nadvances leverage graph representation learning to capture complex inter-table\nrelations as multi-hop dependencies. Despite achieving state-of-the-art\nperformance, these methods remain hindered by the prohibitive storage overhead\nand excessive training time, due to the massive scale of the database and the\ncomputational burden of intensive message passing across interconnected tables.\nTo alleviate these concerns, we propose and study the problem of Relational\nDatabase Distillation (RDD). Specifically, we aim to distill large-scale RDBs\ninto compact heterogeneous graphs while retaining the predictive power (i.e.,\nutility) required for training graph-based models. Multi-modal column\ninformation is preserved through node features, and primary-foreign key\nrelations are encoded via heterogeneous edges, thereby maintaining both data\nfidelity and relational structure. To ensure adaptability across diverse\ndownstream tasks without engaging the traditional, inefficient bi-level\ndistillation framework, we further design a kernel ridge regression-guided\nobjective with pseudo-labels, which produces quality features for the distilled\ngraph. Extensive experiments on multiple real-world RDBs demonstrate that our\nsolution substantially reduces the data size while maintaining competitive\nperformance on classification and regression tasks, creating an effective\npathway for scalable learning with RDBs.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.07062", "pdf": "https://arxiv.org/pdf/2510.07062", "abs": "https://arxiv.org/abs/2510.07062", "authors": ["Hadar Rotschield", "Liat Peterfreund"], "title": "On the Expressiveness of Languages for Querying Property Graphs in Relational Databases", "categories": ["cs.DB"], "comment": null, "summary": "SQL/PGQ is the emerging ISO standard for querying property graphs defined as\nviews over relational data. We formalize its expressive power across three\nfragments: the read-only core, the read-write extension, and an extended\nvariant with richer view definitions. Our results show that graph creation\nplays a central role in determining the expressiveness. The read-only fragment\nis strictly weaker than the read-write fragment, and the latter is still below\nthe complexity class NL. Extending view definitions with arbitrary arity\nidentifiers closes this gap: the extended fragment captures exactly NL. This\nyields a strict hierarchy of SQL/PGQ fragments, whose union covers all NL\nqueries. On ordered structures the hierarchy collapses: once arity-2\nidentifiers are allowed, higher arities add no power, mirroring the classical\ntransitive-closure collapse and underscoring the central role of view\nconstruction in property graph querying.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.06240", "pdf": "https://arxiv.org/pdf/2510.06240", "abs": "https://arxiv.org/abs/2510.06240", "authors": ["Jiqun Pan", "Zhenke Duan", "Jiani Tu", "Anzhi Cheng", "Yanqing Wang"], "title": "Knowledge Graph-Guided Multi-Agent Distillation for Reliable Industrial Question Answering with Datasets", "categories": ["cs.CL", "cs.AI", "cs.DB"], "comment": "41 pages, 12 figures, 6 tables", "summary": "Industrial question-answering (QA) systems require higher safety and\nreliability than general-purpose dialogue models, as errors in high-risk\nscenarios such as equipment fault diagnosis can have severe consequences.\nAlthough multi-agent large language models enhance reasoning depth, they suffer\nfrom uncontrolled iterations and unverifiable outputs, and conventional\ndistillation methods struggle to transfer collaborative reasoning capabilities\nto lightweight, deployable student models. To address these challenges, we\npropose Knowledge Graph-guided Multi-Agent System Distillation (KG-MASD). Our\napproach formulates distillation as a Markov Decision Process and incorporates\na knowledge graph as a verifiable structured prior to enrich state\nrepresentation and ensure convergence. By integrating collaborative reasoning\nwith knowledge grounding, KG-MASD generates high-confidence instruction-tuning\ndata and jointly distills reasoning depth and verifiability into compact\nstudent models suitable for edge deployment. Experiments on an industrial QA\ndataset show that KG-MASD improves accuracy by 2.4 per cent to 20.1 per cent\nover baselines and significantly enhances reliability, enabling trustworthy AI\ndeployment in safety-critical industrial scenarios. Code and data are available\nat https://github.com/erwinmsmith/KG-MAD/.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.06377", "pdf": "https://arxiv.org/pdf/2510.06377", "abs": "https://arxiv.org/abs/2510.06377", "authors": ["Rishabh Ranjan", "Valter Hudovernik", "Mark Znidar", "Charilaos Kanatsoulis", "Roshan Upendra", "Mahmoud Mohammadi", "Joe Meyer", "Tom Palczewski", "Carlos Guestrin", "Jure Leskovec"], "title": "Relational Transformer: Toward Zero-Shot Foundation Models for Relational Data", "categories": ["cs.LG", "cs.AI", "cs.DB"], "comment": "preprint; under review", "summary": "Pretrained transformers readily adapt to new sequence modeling tasks via\nzero-shot prompting, but relational domains still lack architectures that\ntransfer across datasets and tasks. The core challenge is the diversity of\nrelational data, with varying heterogeneous schemas, graph structures and\nfunctional dependencies. In this paper, we present the Relational Transformer\n(RT) architecture, which can be pretrained on diverse relational databases and\ndirectly applied to unseen datasets and tasks without task- or dataset-specific\nfine-tuning, or retrieval of in-context examples. RT (i) tokenizes cells with\ntable/column metadata, (ii) is pretrained via masked token prediction, and\n(iii) utilizes a novel \\textit{Relational Attention} mechanism over columns,\nrows, and primary-foreign key links. Pretrained on RelBench datasets spanning\ntasks such as churn and sales forecasting, RT attains strong zero-shot\nperformance, averaging 94% of fully supervised AUROC on binary classification\ntasks with a single forward pass of a 22M parameter model, as opposed to 84%\nfor a 27B LLM. Fine-tuning yields state-of-the-art results with high sample\nefficiency. Our experiments show that RT's zero-shot transfer harnesses\ntask-table context, relational attention patterns and schema semantics.\nOverall, RT provides a practical path toward foundation models for relational\ndata.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
