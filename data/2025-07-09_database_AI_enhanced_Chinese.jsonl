{"id": "2507.03384", "pdf": "https://arxiv.org/pdf/2507.03384", "abs": "https://arxiv.org/abs/2507.03384", "authors": ["Suchen Liu", "Jun Gao", "Yinjun Han", "Yang Lin"], "title": "LLM4Hint: Leveraging Large Language Models for Hint Recommendation in Offline Query Optimization", "categories": ["cs.DB", "cs.AI"], "comment": null, "summary": "Query optimization is essential for efficient SQL query execution in DBMS,\nand remains attractive over time due to the growth of data volumes and advances\nin hardware. Existing traditional optimizers struggle with the cumbersome\nhand-tuning required for complex workloads, and the learning-based methods face\nlimitations in ensuring generalization. With the great success of Large\nLanguage Model (LLM) across diverse downstream tasks, this paper explores how\nLLMs can be incorporated to enhance the generalization of learned optimizers.\nThough promising, such an incorporation still presents challenges, mainly\nincluding high model inference latency, and the substantial fine-tuning cost\nand suboptimal performance due to inherent discrepancy between the token\nsequences in LLM and structured SQL execution plans with rich numerical\nfeatures.\n  In this paper, we focus on recurring queries in offline optimization to\nalleviate the issue of high inference latency, and propose \\textbf{LLM4Hint}\nthat leverages moderate-sized backbone LLMs to recommend query optimization\nhints. LLM4Hint achieves the goals through: (i) integrating a lightweight model\nto produce a soft prompt, which captures the data distribution in DBMS and the\nSQL predicates to provide sufficient optimization features while simultaneously\nreducing the context length fed to the LLM, (ii) devising a query rewriting\nstrategy using a larger commercial LLM, so as to simplify SQL semantics for the\nbackbone LLM and reduce fine-tuning costs, and (iii) introducing an explicit\nmatching prompt to facilitate alignment between the LLM and the lightweight\nmodel, which can accelerate convergence of the combined model. Experiments show\nthat LLM4Hint, by leveraging the LLM's stronger capability to understand the\nquery statement, can outperform the state-of-the-art learned optimizers in\nterms of both effectiveness and generalization.", "AI": {"tldr": "LLM4Hint \u5229\u7528\u5927\u578b\u8bed\u8a00\u6a21\u578b (LLM) \u6765\u63d0\u5347\u5b66\u4e60\u4f18\u5316\u5668\u7684\u6cdb\u5316\u80fd\u529b\uff0c\u4ece\u800c\u66f4\u6709\u6548\u5730\u63a8\u8350\u67e5\u8be2\u4f18\u5316\u63d0\u793a\u3002", "motivation": "\u73b0\u6709\u7684\u4f20\u7edf\u4f18\u5316\u5668\u5728\u590d\u6742\u5de5\u4f5c\u8d1f\u8f7d\u6240\u9700\u7684\u624b\u52a8\u8c03\u6574\u65b9\u9762\u5b58\u5728\u56f0\u96be\uff0c\u5e76\u4e14\u57fa\u4e8e\u5b66\u4e60\u7684\u65b9\u6cd5\u5728\u786e\u4fdd\u6cdb\u5316\u65b9\u9762\u9762\u4e34\u9650\u5236\u3002\u5927\u578b\u8bed\u8a00\u6a21\u578b (LLM) \u5728\u5404\u79cd\u4e0b\u6e38\u4efb\u52a1\u4e2d\u53d6\u5f97\u4e86\u5de8\u5927\u7684\u6210\u529f\uff0c\u672c\u6587\u63a2\u8ba8\u4e86\u5982\u4f55\u6574\u5408 LLM \u4ee5\u589e\u5f3a\u5b66\u4e60\u4f18\u5316\u5668\u7684\u6cdb\u5316\u80fd\u529b\u3002", "method": "\u8be5\u8bba\u6587\u63d0\u51fa LLM4Hint\uff0c\u5b83\u5229\u7528\u4e2d\u7b49\u89c4\u6a21\u7684\u9aa8\u5e72 LLM \u6765\u63a8\u8350\u67e5\u8be2\u4f18\u5316\u63d0\u793a\u3002LLM4Hint \u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5b9e\u73b0\u76ee\u6807\uff1a(i) \u96c6\u6210\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u6a21\u578b\u6765\u751f\u6210\u8f6f\u63d0\u793a\uff0c\u6355\u83b7 DBMS \u4e2d\u7684\u6570\u636e\u5206\u5e03\u548c SQL \u8c13\u8bcd\uff0c\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4f18\u5316\u7279\u5f81\uff0c\u540c\u65f6\u51cf\u5c11\u8f93\u5165\u5230 LLM \u7684\u4e0a\u4e0b\u6587\u957f\u5ea6\uff0c(ii) \u8bbe\u8ba1\u4f7f\u7528\u66f4\u5927\u7684\u5546\u4e1a LLM \u7684\u67e5\u8be2\u91cd\u5199\u7b56\u7565\uff0c\u4ece\u800c\u7b80\u5316\u9aa8\u5e72 LLM \u7684 SQL \u8bed\u4e49\u5e76\u964d\u4f4e\u5fae\u8c03\u6210\u672c\uff0c\u4ee5\u53ca (iii) \u5f15\u5165\u663e\u5f0f\u5339\u914d\u63d0\u793a\u4ee5\u4fc3\u8fdb LLM \u548c\u8f7b\u91cf\u7ea7\u6a21\u578b\u4e4b\u95f4\u7684\u5bf9\u9f50\uff0c\u4ece\u800c\u52a0\u901f\u7ec4\u5408\u6a21\u578b\u7684\u6536\u655b\u3002", "result": "LLM4Hint \u5728\u6709\u6548\u6027\u548c\u6cdb\u5316\u6027\u65b9\u9762\u4f18\u4e8e\u6700\u5148\u8fdb\u7684\u5b66\u4e60\u4f18\u5316\u5668\u3002", "conclusion": "\u5b9e\u9a8c\u8868\u660e\uff0cLLM4Hint \u901a\u8fc7\u5229\u7528 LLM \u66f4\u5f3a\u7684\u7406\u89e3\u67e5\u8be2\u8bed\u53e5\u7684\u80fd\u529b\uff0c\u5728\u6709\u6548\u6027\u548c\u6cdb\u5316\u6027\u65b9\u9762\u4f18\u4e8e\u6700\u5148\u8fdb\u7684\u5b66\u4e60\u4f18\u5316\u5668\u3002", "summary_zh": "\u67e5\u8be2\u4f18\u5316\u5bf9\u4e8e DBMS \u4e2d\u9ad8\u6548\u7684 SQL \u67e5\u8be2\u6267\u884c\u81f3\u5173\u91cd\u8981\uff0c\u5e76\u4e14\u7531\u4e8e\u6570\u636e\u91cf\u7684\u589e\u957f\u548c\u786c\u4ef6\u7684\u8fdb\u6b65\uff0c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u4ecd\u7136\u5177\u6709\u5438\u5f15\u529b\u3002\u73b0\u6709\u7684\u4f20\u7edf\u4f18\u5316\u5668\u5728\u590d\u6742\u5de5\u4f5c\u8d1f\u8f7d\u6240\u9700\u7684\u624b\u52a8\u8c03\u6574\u65b9\u9762\u5b58\u5728\u56f0\u96be\uff0c\u5e76\u4e14\u57fa\u4e8e\u5b66\u4e60\u7684\u65b9\u6cd5\u5728\u786e\u4fdd\u6cdb\u5316\u65b9\u9762\u9762\u4e34\u9650\u5236\u3002 \u968f\u7740\u5927\u578b\u8bed\u8a00\u6a21\u578b (LLM) \u5728\u5404\u79cd\u4e0b\u6e38\u4efb\u52a1\u4e2d\u53d6\u5f97\u4e86\u5de8\u5927\u7684\u6210\u529f\uff0c\u672c\u6587\u63a2\u8ba8\u4e86\u5982\u4f55\u6574\u5408 LLM \u4ee5\u589e\u5f3a\u5b66\u4e60\u4f18\u5316\u5668\u7684\u6cdb\u5316\u80fd\u529b\u3002 \u5c3d\u7ba1\u524d\u666f\u5e7f\u9614\uff0c\u4f46\u8fd9\u79cd\u6574\u5408\u4ecd\u7136\u5b58\u5728\u6311\u6218\uff0c\u4e3b\u8981\u5305\u62ec\u9ad8\u6a21\u578b\u63a8\u7406\u5ef6\u8fdf\uff0c\u4ee5\u53ca\u7531\u4e8e LLM \u4e2d\u4ee4\u724c\u5e8f\u5217\u4e0e\u5177\u6709\u4e30\u5bcc\u6570\u503c\u7279\u5f81\u7684\u7ed3\u6784\u5316 SQL \u6267\u884c\u8ba1\u5212\u4e4b\u95f4\u7684\u56fa\u6709\u5dee\u5f02\u800c\u5bfc\u81f4\u7684\u5927\u91cf\u5fae\u8c03\u6210\u672c\u548c\u6b21\u4f18\u6027\u80fd\u3002\u5728\u672c\u6587\u4e2d\uff0c\u6211\u4eec\u4e13\u6ce8\u4e8e\u79bb\u7ebf\u4f18\u5316\u4e2d\u7684\u91cd\u590d\u67e5\u8be2\uff0c\u4ee5\u7f13\u89e3\u9ad8\u63a8\u7406\u5ef6\u8fdf\u7684\u95ee\u9898\uff0c\u5e76\u63d0\u51fa LLM4Hint\uff0c\u5b83\u5229\u7528\u4e2d\u7b49\u89c4\u6a21\u7684\u9aa8\u5e72 LLM \u6765\u63a8\u8350\u67e5\u8be2\u4f18\u5316\u63d0\u793a\u3002 LLM4Hint \u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5b9e\u73b0\u76ee\u6807\uff1a(i) \u96c6\u6210\u4e00\u4e2a\u8f7b\u91cf\u7ea7\u6a21\u578b\u6765\u751f\u6210\u8f6f\u63d0\u793a\uff0c\u6355\u83b7 DBMS \u4e2d\u7684\u6570\u636e\u5206\u5e03\u548c SQL \u8c13\u8bcd\uff0c\u4ee5\u63d0\u4f9b\u8db3\u591f\u7684\u4f18\u5316\u7279\u5f81\uff0c\u540c\u65f6\u51cf\u5c11\u8f93\u5165\u5230 LLM \u7684\u4e0a\u4e0b\u6587\u957f\u5ea6\uff0c(ii) \u8bbe\u8ba1\u4f7f\u7528\u66f4\u5927\u7684\u5546\u4e1a LLM \u7684\u67e5\u8be2\u91cd\u5199\u7b56\u7565\uff0c\u4ece\u800c\u7b80\u5316\u9aa8\u5e72 LLM \u7684 SQL \u8bed\u4e49\u5e76\u964d\u4f4e\u5fae\u8c03\u6210\u672c\uff0c\u4ee5\u53ca (iii) \u5f15\u5165\u663e\u5f0f\u5339\u914d\u63d0\u793a\u4ee5\u4fc3\u8fdb LLM \u548c\u8f7b\u91cf\u7ea7\u6a21\u578b\u4e4b\u95f4\u7684\u5bf9\u9f50\uff0c\u4ece\u800c\u52a0\u901f\u7ec4\u5408\u6a21\u578b\u7684\u6536\u655b\u3002 \u5b9e\u9a8c\u8868\u660e\uff0cLLM4Hint \u901a\u8fc7\u5229\u7528 LLM \u66f4\u5f3a\u7684\u7406\u89e3\u67e5\u8be2\u8bed\u53e5\u7684\u80fd\u529b\uff0c\u5728\u6709\u6548\u6027\u548c\u6cdb\u5316\u6027\u65b9\u9762\u4f18\u4e8e\u6700\u5148\u8fdb\u7684\u5b66\u4e60\u4f18\u5316\u5668\u3002"}}
{"id": "2507.03919", "pdf": "https://arxiv.org/pdf/2507.03919", "abs": "https://arxiv.org/abs/2507.03919", "authors": ["Duy Le"], "title": "PFCS: Prime Factorization Cache System for Deterministic Data Relationship Discovery", "categories": ["cs.DB", "cs.CC"], "comment": "6 pages, 3 figures, 3 algorithms", "summary": "Cache systems fundamentally limit modern computing performance due to their\ninability to precisely capture data relationships. While achieving 85-92% hit\nrates, traditional systems rely on statistical heuristics that cannot guarantee\nrelationship discovery, leading to suboptimal prefetching and resource waste.\nWe present PFCS (Prime Factorization Cache System), which leverages the\nmathematical uniqueness of prime factorization to achieve deterministic\nrelationship discovery with zero false positives. PFCS assigns unique primes to\ndata elements and represents relationships as composite numbers, enabling the\nrecovery of perfect relationships through factorization. A comprehensive\nevaluation across database, ML, and HPC workloads demonstrates an average\nperformance improvement of x 6.2, 98.9% hit rates, and a 38% power reduction\ncompared to state-of-the-art systems. The mathematical foundation provides\nformal guarantees impossible with approximation-based approaches, establishing\na new paradigm for cache system design", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2507.04256", "pdf": "https://arxiv.org/pdf/2507.04256", "abs": "https://arxiv.org/abs/2507.04256", "authors": ["Tang Qian", "Yifan Zhu", "Lu Chen", "Xiangyu Ke", "Jingwen Zhao", "Tianyi Li", "Yunjun Gao", "Christian S. Jensen"], "title": "OneDB: A Distributed Multi-Metric Data Similarity Search System", "categories": ["cs.DB"], "comment": null, "summary": "Increasingly massive volumes of multi-modal data are being accumulated in\nmany {real world} settings, including in health care and e-commerce. This\ndevelopment calls for effective general-purpose data management solutions for\nmulti-modal data. Such a solution must facilitate user-friendly and accurate\nretrieval of any multi-modal data according to diverse application\nrequirements. Further, such a solution must be capable of efficient and\nscalable retrieval.\n  To address this need, we present OneDB, a distributed multi-metric data\nsimilarity retrieval system. This system exploits the fact that data of diverse\nmodalities, such as text, images, and video, can be represented as metric data.\nThe system thus affords each data modality its own metric space with its own\ndistance function and then uses a multi-metric model to unify multi-modal data.\nThe system features several innovations: (i) an extended Spart SQL query\ninterface; (ii) lightweight means of learning appropriate weights of different\nmodalities when retrieving multi-modal data to enable accurate retrieval; (iii)\nsmart search-space pruning strategies that improve efficiency; (iv) two-layered\nindexing of data to ensure load-balancing during distributed processing; and\n(v) end-to-end system parameter autotuning.\n  Experiments on three real-life datasets and two synthetic datasets offer\nevidence that the system is capable of state-of-the-art performance: (i)\nefficient and effective weight learning; (ii) retrieval accuracy improvements\nof 12.63\\%--30.75\\% over the state-of-the-art vector similarity search system\nat comparable efficiency; (iii) accelerated search by 2.5--5.75x over\nstate-of-the-art single- or multi-metric solutions; (iv) demonstrated high\nscalability; and (v) parameter tuning that enables performance improvements of\n15+%.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2507.04687", "pdf": "https://arxiv.org/pdf/2507.04687", "abs": "https://arxiv.org/abs/2507.04687", "authors": ["Zhenwei Dai", "Chuan Lei", "Asterios Katsifodimos", "Xiao Qin", "Christos Faloutsos", "Huzefa Rangwala"], "title": "AKEGEN: A LLM-based Tabular Corpus Generator for Evaluating Dataset Discovery in Data Lakes", "categories": ["cs.DB"], "comment": "13 pages", "summary": "How to generate a large, realistic set of tables along with joinability\nrelationships, to stress-test dataset discovery methods? Dataset discovery\nmethods aim to automatically identify related data assets in a data lake. The\ndevelopment and evaluation of such solutions for customers from a wide range of\nbusiness domains, relies on diverse, high quality and domain-specific tabular\nbenchmarks. Large language models (LLMs) are trained on a wide variety of text\ndata, which can provide a strong foundation of general and domain-specific\nknowledge. In this paper, we ask the question -- \\textit{can we leverage LLMs\nto generate a tabular benchmark adequate for evaluating the dataset discovery\nsolutions?} In particular, we focus on the task of finding joinable tables\nwhich is the cornerstone of virtually every dataset discovery method. Current\ncorpora for evaluating dataset discovery methods are mainly based on subsets of\nopen data, and they suffer from three important issues: $i)$ they focus on very\ncommon and generic data types (e.g., address, id, name, etc.); $ii)$ they do\nnot contain human-annotated column pairs; instead, practitioners synthesize\nground truth using table splits (e.g., horizontal for table union search and\nvertical ones for joinability) and $iii)$ they do not focus on semantic column\nrelationships.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2507.04872", "pdf": "https://arxiv.org/pdf/2507.04872", "abs": "https://arxiv.org/abs/2507.04872", "authors": ["Cong Yu", "Tuo Shi", "Matthias Weidlich", "Bo Zhao"], "title": "SHARP: Shared State Reduction for Efficient Matching of Sequential Patterns", "categories": ["cs.DB"], "comment": null, "summary": "The detection of sequential patterns in data is a basic functionality of\nmodern data processing systems for complex event processing (CEP), OLAP, and\nretrieval-augmented generation (RAG). In practice, pattern matching is\nchallenging, since common applications rely on a large set of patterns that\nshall be evaluated with tight latency bounds. At the same time, matching needs\nto maintain state, i.e., intermediate results, that grows exponentially in the\ninput size. Hence, systems turn to best-effort processing, striving for maximal\nrecall under a latency bound. Existing techniques, however, consider each\npattern in isolation, neglecting the optimization potential induced by state\nsharing in pattern matching.\n  In this paper, we present SHARP, a library that employs state reduction to\nachieve efficient best-effort pattern matching. To this end, SHARP incorporates\nstate sharing between patterns through a new abstraction, coined\npattern-sharing degree (PSD). At runtime, this abstraction facilitates the\ncategorization and indexing of partial pattern matches. Based thereon, once a\nlatency bound is exceeded, SHARP realizes best-effort processing by selecting a\nsubset of partial matches for further processing in constant time. In\nexperiments with real-world data, SHARP achieves a recall of 97%, 96% and 73%\nfor pattern matching in CEP, OLAP, and RAG applications, under a bound of 50%\nof the average processing latency.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2507.04967", "pdf": "https://arxiv.org/pdf/2507.04967", "abs": "https://arxiv.org/abs/2507.04967", "authors": ["Bardia Mohammadi", "Laurent Bindschaedler"], "title": "The Case for Instance-Optimized LLMs in OLAP Databases", "categories": ["cs.DB", "cs.LG"], "comment": null, "summary": "Large Language Models (LLMs) can enhance analytics systems with powerful data\nsummarization, cleaning, and semantic transformation capabilities. However,\ndeploying LLMs at scale -- processing millions to billions of rows -- remains\nprohibitively expensive in computation and memory. We present IOLM-DB, a novel\nsystem that makes LLM-enhanced database queries practical through\nquery-specific model optimization. Instead of using general-purpose LLMs,\nIOLM-DB generates lightweight, specialized models tailored to each query's\nspecific needs using representative data samples. IOLM-DB reduces model\nfootprints by up to 76% and increases throughput by up to 3.31$\\times$ while\nmaintaining accuracy through aggressive compression techniques, including\nquantization, sparsification, and structural pruning. We further show how our\napproach enables higher parallelism on existing hardware and seamlessly\nsupports caching and batching strategies to reduce overheads. Our prototype\ndemonstrates that leveraging LLM queries inside analytics systems is feasible\nat scale, opening new possibilities for future OLAP applications.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2507.03410", "pdf": "https://arxiv.org/pdf/2507.03410", "abs": "https://arxiv.org/abs/2507.03410", "authors": ["Hrishikesh Terdalkar", "Angela Bonifati", "Andrea Mauri"], "title": "Graph Repairs with Large Language Models: An Empirical Study", "categories": ["cs.CL", "cs.DB", "cs.ET"], "comment": "Accepted to the 8th GRADES-NDA 2025 @ SIGMOD/PODS 2025", "summary": "Property graphs are widely used in domains such as healthcare, finance, and\nsocial networks, but they often contain errors due to inconsistencies, missing\ndata, or schema violations. Traditional rule-based and heuristic-driven graph\nrepair methods are limited in their adaptability as they need to be tailored\nfor each dataset. On the other hand, interactive human-in-the-loop approaches\nmay become infeasible when dealing with large graphs, as the cost--both in\nterms of time and effort--of involving users becomes too high. Recent\nadvancements in Large Language Models (LLMs) present new opportunities for\nautomated graph repair by leveraging contextual reasoning and their access to\nreal-world knowledge. We evaluate the effectiveness of six open-source LLMs in\nrepairing property graphs. We assess repair quality, computational cost, and\nmodel-specific performance. Our experiments show that LLMs have the potential\nto detect and correct errors, with varying degrees of accuracy and efficiency.\nWe discuss the strengths, limitations, and challenges of LLM-driven graph\nrepair and outline future research directions for improving scalability and\ninterpretability.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
