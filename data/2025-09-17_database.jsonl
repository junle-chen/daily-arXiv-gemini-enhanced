{"id": "2509.10714", "pdf": "https://arxiv.org/pdf/2509.10714", "abs": "https://arxiv.org/abs/2509.10714", "authors": ["Tony Astolfi", "Vidya Silai", "Darby Huye", "Lan Liu", "Raja R. Sambasivan", "Johes Bater"], "title": "Dynamic read & write optimization with TurtleKV", "categories": ["cs.DB"], "comment": null, "summary": "High read and write performance is important for generic key/value stores,\nwhich are fundamental to modern applications and databases. Yet, achieving high\nperformance for both reads and writes is challenging due to traditionally\nlimited memory and the pick-any-two-out-of-three tradeoff between memory use,\nread performance, and write performance. Existing state-of-the-art approaches\nlimit memory usage and chose a primary dimension (reads or writes) for which to\noptimize their on-disk structures. They recover performance in the remaining\ndimension by other mechanisms. This approach limits databases' maximum\nperformance in the remaining dimension and their dynamic (online) tunability to\nrespond to changing workloads. We explore a different approach that dynamically\ntrades memory for read or write performance as needed. We present TurtleKV,\nwhich includes a novel unbiased data structure for on-disk storage. It includes\na knob that dynamically increases memory reserved for increasing read or write\nperformance. When evaluated on YCSB, TurtleKV achieves up to 8x the write\nthroughput of industry-leader RocksDB and up to 5x the read throughput while\nincurring similar space amplification. Compared to the state-of-the-art system\nSplinterDB, TurtleKV runs up to 40% better on point queries, up to 6x better on\nrange scans and achieves similar write performance, while incurring 50% less\nspace amplification."}
{"id": "2509.11920", "pdf": "https://arxiv.org/pdf/2509.11920", "abs": "https://arxiv.org/abs/2509.11920", "authors": ["Kyle Deeds", "Timo Camillo Merkl", "Reinhard Pichler", "Dan Suciu"], "title": "The Space-Time Complexity of Sum-Product Queries", "categories": ["cs.DB"], "comment": null, "summary": "While extensive research on query evaluation has achieved consistent\nimprovements in the time complexity of algorithms, the space complexity of\nquery evaluation has been largely ignored. This is a particular challenge in\nsettings with strict pre-defined space constraints. In this paper, we examine\nthe combined space-time complexity of conjunctive queries (CQs) and, more\ngenerally, of sum-product queries (SPQs). We propose several classes of\nspace-efficient algorithms for evaluating SPQs, and we show that the optimal\ntime complexity is almost always achievable with asymptotically lower space\ncomplexity than traditional approaches."}
{"id": "2509.11929", "pdf": "https://arxiv.org/pdf/2509.11929", "abs": "https://arxiv.org/abs/2509.11929", "authors": ["Marcelo Arenas", "Timo Camillo Merkl", "Reinhard Pichler", "Cristian Riveros"], "title": "Query Answering under Volume-Based Diversity Functions", "categories": ["cs.DB"], "comment": null, "summary": "When query evaluation produces too many tuples, a new approach in query\nanswering is to retrieve a diverse subset of them. The standard approach for\nmeasuring the diversity of a set of tuples is to use a distance function\nbetween tuples, which measures the dissimilarity between them, to then\naggregate the pairwise distances of the set into a score (e.g., by using sum or\nmin aggregation). However, as we will point out in this work, the resulting\ndiversity measures may display some unintuitive behavior. Moreover, even in\nvery simple settings, finding a maximally diverse subset of the answers of\nfixed size is, in general, intractable and little is known about approximations\napart from some hand-picked distance-aggregator pairs.\n  In this work, we introduce a novel approach for computing the diversity of\ntuples based on volume instead of distance. We present a framework for defining\nvolume-based diversity functions and provide several examples of these measures\napplied to relational data. Although query answering of conjunctive queries\n(CQ) under this setting is intractable in general, we show that one can always\ncompute a (1-1/e)-approximation for any volume-based diversity function.\nFurthermore, in terms of combined complexity, we connect the evaluation of CQs\nunder volume-based diversity functions with the ranked enumeration of\nsolutions, finding general conditions under which a (1-1/e)-approximation can\nbe computed in polynomial time."}
{"id": "2509.12086", "pdf": "https://arxiv.org/pdf/2509.12086", "abs": "https://arxiv.org/abs/2509.12086", "authors": ["Hui Li", "Shiyuan Deng", "Xiao Yan", "Xiangyu Zhi", "James Cheng"], "title": "SAQ: Pushing the Limits of Vector Quantization through Code Adjustment and Dimension Segmentation", "categories": ["cs.DB", "cs.DS", "cs.IR"], "comment": "13 pages, 12 figures, accepted by SIGMOD", "summary": "Approximate Nearest Neighbor Search (ANNS) plays a critical role in\napplications such as search engines, recommender systems, and RAG for LLMs.\nVector quantization (VQ), a crucial technique for ANNS, is commonly used to\nreduce space overhead and accelerate distance computations. However, despite\nsignificant research advances, state-of-the-art VQ methods still face\nchallenges in balancing encoding efficiency and quantization accuracy. To\naddress these limitations, we propose a novel VQ method called SAQ. To improve\naccuracy, SAQ employs a new dimension segmentation technique to strategically\npartition PCA-projected vectors into segments along their dimensions. By\nprioritizing leading dimension segments with larger magnitudes, SAQ allocates\nmore bits to high-impact segments, optimizing the use of the available space\nquota. An efficient dynamic programming algorithm is developed to optimize\ndimension segmentation and bit allocation, ensuring minimal quantization error.\nTo speed up vector encoding, SAQ devises a code adjustment technique to first\nquantize each dimension independently and then progressively refine quantized\nvectors using a coordinate-descent-like approach to avoid exhaustive\nenumeration. Extensive experiments demonstrate SAQ's superiority over classical\nmethods (e.g., PQ, PCA) and recent state-of-the-art approaches (e.g., LVQ,\nExtended RabitQ). SAQ achieves up to 80% reduction in quantization error and\naccelerates encoding speed by over 80x compared to Extended RabitQ."}
{"id": "2509.12189", "pdf": "https://arxiv.org/pdf/2509.12189", "abs": "https://arxiv.org/abs/2509.12189", "authors": ["Elena Botoeva", "Julien Corman"], "title": "Towards a Standard for JSON Document Databases", "categories": ["cs.DB"], "comment": null, "summary": "In this technical report, we present a formalisation of the MongoDB\naggregation framework. Our aim is to identify a fragment that could serve as\nthe starting point for an industry-wide standard for querying JSON document\ndatabases. We provide a syntax and formal semantics for a set of selected\noperators, We show how this fragment relates to known relational query\nlanguages. We explain how our semantics differs from the current implementation\nof MongoDB, and justify our choices. We provide a set of algebraic\ntransformations that can be used for query optimisation."}
{"id": "2509.10572", "pdf": "https://arxiv.org/pdf/2509.10572", "abs": "https://arxiv.org/abs/2509.10572", "authors": ["Ashlesha Akella", "Akshar Kaul", "Krishnasuri Narayanam", "Sameep Mehta"], "title": "Quality Assessment of Tabular Data using Large Language Models and Code Generation", "categories": ["cs.SE", "cs.AI", "cs.DB"], "comment": "EMNLP industry track submitted", "summary": "Reliable data quality is crucial for downstream analysis of tabular datasets,\nyet rule-based validation often struggles with inefficiency, human\nintervention, and high computational costs. We present a three-stage framework\nthat combines statistical inliner detection with LLM-driven rule and code\ngeneration. After filtering data samples through traditional clustering, we\niteratively prompt LLMs to produce semantically valid quality rules and\nsynthesize their executable validators through code-generating LLMs. To\ngenerate reliable quality rules, we aid LLMs with retrieval-augmented\ngeneration (RAG) by leveraging external knowledge sources and domain-specific\nfew-shot examples. Robust guardrails ensure the accuracy and consistency of\nboth rules and code snippets. Extensive evaluations on benchmark datasets\nconfirm the effectiveness of our approach."}
{"id": "2509.10793", "pdf": "https://arxiv.org/pdf/2509.10793", "abs": "https://arxiv.org/abs/2509.10793", "authors": ["Eli Baum", "Sam Buxbaum", "Nitin Mathai", "Muhammad Faisal", "Vasiliki Kalavri", "Mayank Varia", "John Liagouris"], "title": "ORQ: Complex Analytics on Private Data with Strong Security Guarantees", "categories": ["cs.CR", "cs.DB"], "comment": "14 pages, plus Appendix. To appear at SOSP 2025. Code published at\n  https://github.com/CASP-Systems-BU/orq", "summary": "We present ORQ, a system that enables collaborative analysis of large private\ndatasets using cryptographically secure multi-party computation (MPC). ORQ\nprotects data against semi-honest or malicious parties and can efficiently\nevaluate relational queries with multi-way joins and aggregations that have\nbeen considered notoriously expensive under MPC. To do so, ORQ eliminates the\nquadratic cost of secure joins by leveraging the fact that, in practice, the\nstructure of many real queries allows us to join records and apply the\naggregations \"on the fly\" while keeping the result size bounded. On the system\nside, ORQ contributes generic oblivious operators, a data-parallel vectorized\nquery engine, a communication layer that amortizes MPC network costs, and a\ndataflow API for expressing relational analytics -- all built from the ground\nup.\n  We evaluate ORQ in LAN and WAN deployments on a diverse set of workloads,\nincluding complex queries with multiple joins and custom aggregations. When\ncompared to state-of-the-art solutions, ORQ significantly reduces MPC execution\ntimes and can process one order of magnitude larger datasets. For our most\nchallenging workload, the full TPC-H benchmark, we report results entirely\nunder MPC with Scale Factor 10 -- a scale that had previously been achieved\nonly with information leakage or the use of trusted third parties."}
