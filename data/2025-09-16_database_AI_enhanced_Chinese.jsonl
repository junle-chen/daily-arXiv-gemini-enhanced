{"id": "2509.10050", "pdf": "https://arxiv.org/pdf/2509.10050", "abs": "https://arxiv.org/abs/2509.10050", "authors": ["Aryan Esmailpour", "Xiao Hu", "Stavros Sintos"], "title": "Space-Time Tradeoffs for Spatial Conjunctive Queries", "categories": ["cs.DB"], "comment": null, "summary": "Given a conjunctive query and a database instance, we aim to develop an index\nthat can efficiently answer spatial queries on the results of a conjunctive\nquery. We are interested in some commonly used spatial queries, such as range\nemptiness, range count, and nearest neighbor queries. These queries have\nessential applications in data analytics, such as filtering relational data\nbased on attribute ranges and temporal graph analysis for counting graph\nstructures like stars, paths, and cliques. Furthermore, this line of research\ncan accelerate relational algorithms that incorporate spatial queries in their\nworkflow, such as relational clustering. Known approaches either have to spend\n$\\tilde{O}(N)$ query time or use space as large as the number of query results,\nwhich are inefficient or unrealistic to employ in practice. Hence, we aim to\nconstruct an index that answers spatial conjunctive queries in both time- and\nspace-efficient ways.\n  In this paper, we establish lower bounds on the tradeoff between answering\ntime and space usage. For $k$-star (resp. $k$-path) queries, we show that any\nindex for range emptiness, range counting or nearest neighbor queries with $T$\nanswering time requires $\\Omega\\left(N+\\frac{N^k}{T^k}\\right)$ (resp.\n$\\Omega\\left(N+\\frac{N^2}{T^{2/(k-1)}}\\right)$) space. Then, we construct\noptimal indexes for answering range emptiness and range counting problems over\n$k$-star and $k$-path queries. Extending this result, we build an index for\nhierarchical queries. By resorting to the generalized hypertree decomposition,\nwe can extend our index to arbitrary conjunctive queries for supporting spatial\nconjunctive queries. Finally, we show how our new indexes can be used to\nimprove the running time of known algorithms in the relational setting.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2509.10138", "pdf": "https://arxiv.org/pdf/2509.10138", "abs": "https://arxiv.org/abs/2509.10138", "authors": ["Foto N. Afrati", "Matthew Damigos"], "title": "Semi-interval Comparison Constraints in Query Containment and Their Impact on Certain Answer Computation", "categories": ["cs.DB", "H.2.3, F.2.0"], "comment": "71 pages 2 figures", "summary": "We consider conjunctive queries with arithmetic comparisons (CQAC) and\ninvestigate the computational complexity of the problem: Given two CQAC\nqueries, $Q$ and $Q'$, is $Q'$ contained in $Q$? We know that, for CQAC\nqueries, the problem of testing containment is $\\Pi_2 ^p$ -complete. However,\nthere are broad classes of queries with semi-interval arithmetic comparisons in\nthe containing query that render the problem solvable in NP. In all cases\nexamined the contained query is allowed to be any CQAC. Interestingly, we also\nprove that there are simple cases where the problem remains $\\Pi_2 ^p$\n-complete.\n  We also investigate the complexity of computing certain answers in the\nframework of answering CQAC queries with semi-interval comparisons using any\nCQAC views. We prove that maximally contained rewritings in the language of\nunion of CQACs always compute exactly all certain answers. We find cases where\nwe can compute certain answers in polynomial time using maximally contained\nrewritings.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2509.09684", "pdf": "https://arxiv.org/pdf/2509.09684", "abs": "https://arxiv.org/abs/2509.09684", "authors": ["Bruno Yui Yamate", "Thais Rodrigues Neubauer", "Marcelo Fantinato", "Sarajane Marques Peres"], "title": "Text-to-SQL Oriented to the Process Mining Domain: A PT-EN Dataset for Query Translation", "categories": ["cs.IR", "cs.AI", "cs.CL", "cs.DB"], "comment": "33 pages", "summary": "This paper introduces text-2-SQL-4-PM, a bilingual (Portuguese-English)\nbenchmark dataset designed for the text-to-SQL task in the process mining\ndomain. Text-to-SQL conversion facilitates natural language querying of\ndatabases, increasing accessibility for users without SQL expertise and\nproductivity for those that are experts. The text-2-SQL-4-PM dataset is\ncustomized to address the unique challenges of process mining, including\nspecialized vocabularies and single-table relational structures derived from\nevent logs. The dataset comprises 1,655 natural language utterances, including\nhuman-generated paraphrases, 205 SQL statements, and ten qualifiers. Methods\ninclude manual curation by experts, professional translations, and a detailed\nannotation process to enable nuanced analyses of task complexity. Additionally,\na baseline study using GPT-3.5 Turbo demonstrates the feasibility and utility\nof the dataset for text-to-SQL applications. The results show that\ntext-2-SQL-4-PM supports evaluation of text-to-SQL implementations, offering\nbroader applicability for semantic parsing and other natural language\nprocessing tasks.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2509.09691", "pdf": "https://arxiv.org/pdf/2509.09691", "abs": "https://arxiv.org/abs/2509.09691", "authors": ["Aleksandr Listopad"], "title": "Wave-Based Semantic Memory with Resonance-Based Retrieval: A Phase-Aware Alternative to Vector Embedding Stores", "categories": ["cs.IR", "cs.AI", "cs.DB", "68T05 (Primary), 42C10, 94A12 (Secondary)", "I.2.6; H.2.4; H.3.3"], "comment": "9 pages, 6 figures", "summary": "Conventional vector-based memory systems rely on cosine or inner product\nsimilarity within real-valued embedding spaces. While computationally\nefficient, such approaches are inherently phase-insensitive and limited in\ntheir ability to capture resonance phenomena crucial for meaning\nrepresentation. We propose Wave-Based Semantic Memory, a novel framework that\nmodels knowledge as wave patterns $\\psi(x) = A(x) e^{i\\phi(x)}$ and retrieves\nit through resonance-based interference. This approach preserves both amplitude\nand phase information, enabling more expressive and robust semantic similarity.\nWe demonstrate that resonance-based retrieval achieves higher discriminative\npower in cases where vector methods fail, including phase shifts, negations,\nand compositional queries. Our implementation, ResonanceDB, shows scalability\nto millions of patterns with millisecond latency, positioning wave-based memory\nas a viable alternative to vector stores for AGI-oriented reasoning and\nknowledge representation.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2509.09795", "pdf": "https://arxiv.org/pdf/2509.09795", "abs": "https://arxiv.org/abs/2509.09795", "authors": ["Arivarasan Karmegam", "Gabina Luz Bianchi", "Margarita Capretto", "Mart\u00edn Ceresa", "Antonio Fern\u00e1ndez Anta", "C\u00e9sar S\u00e1nchez"], "title": "Setchain Algorithms for Blockchain Scalability", "categories": ["cs.DC", "cs.DB", "cs.DS", "cs.PF"], "comment": null, "summary": "Setchain has been proposed to increase blockchain scalability by relaxing the\nstrict total order requirement among transactions. Setchain organizes elements\ninto a sequence of sets, referred to as epochs, so that elements within each\nepoch are unordered. In this paper, we propose and evaluate three distinct\nSetchain algorithms, that leverage an underlying block-based ledger. Vanilla is\na basic implementation that serves as a reference point. Compresschain\naggregates elements into batches, and compresses these batches before appending\nthem as epochs in the ledger. Hashchain converts batches into fixed-length\nhashes which are appended as epochs in the ledger. This requires Hashchain to\nuse a distributed service to obtain the batch contents from its hash. To allow\nlight clients to safely interact with only one server, the proposed algorithms\nmaintain, as part of the Setchain, proofs for the epochs. An epoch-proof is the\nhash of the epoch, cryptographically signed by a server. A client can verify\nthe correctness of an epoch with $f+1$ epoch-proofs (where $f$ is the maximum\nnumber of Byzantine servers assumed). All three Setchain algorithms are\nimplemented on top of the CometBFT blockchain application platform. We\nconducted performance evaluations across various configurations, using clusters\nof four, seven, and ten servers. Our results show that the Setchain algorithms\nreach orders of magnitude higher throughput than the underlying blockchain, and\nachieve finality with latency below 4 seconds.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2509.09898", "pdf": "https://arxiv.org/pdf/2509.09898", "abs": "https://arxiv.org/abs/2509.09898", "authors": ["Sophia Lockton", "Jeremy Kepner", "Michael Stonebraker", "Hayden Jananthan", "LaToya Anderson", "William Arcand", "David Bestor", "William Bergeron", "Alex Bonn", "Daniel Burrill", "Chansup Byun", "Timothy Davis", "Vijay Gadepally", "Michael Houle", "Matthew Hubbell", "Michael Jones", "Piotr Luszczek", "Peter Michaleas", "Lauren Milechin", "Chasen Milner", "Guillermo Morales", "Julie Mullen", "Michel Pelletier", "Alex Poliakov", "Andrew Prout", "Albert Reuther", "Antonio Rosa", "Charles Yee", "Alex Pentland"], "title": "DBOS Network Sensing: A Web Services Approach to Collaborative Awareness", "categories": ["cs.NI", "cs.CR", "cs.DB", "cs.DC", "cs.OS"], "comment": "8 pages, 10 figures, 37 references, accepted to IEEE HPEC 2025", "summary": "DBOS (DataBase Operating System) is a novel capability that integrates web\nservices, operating system functions, and database features to significantly\nreduce web-deployment effort while increasing resilience. Integration of high\nperformance network sensing enables DBOS web services to collaboratively create\na shared awareness of their network environments to enhance their collective\nresilience and security. Network sensing is added to DBOS using GraphBLAS\nhypersparse traffic matrices via two approaches: (1) Python-GraphBLAS and (2)\nOneSparse PostgreSQL. These capabilities are demonstrated using the workflow\nand analytics from the IEEE/MIT/Amazon Anonymized Network Sensing Graph\nChallenge. The system was parallelized using pPython and benchmarked using 64\ncompute nodes on the MIT SuperCloud. The web request rate sustained by a single\nDBOS instance was ${>}10^5$, well above the required maximum, indicating that\nnetwork sensing can be added to DBOS with negligible overhead. For\ncollaborative awareness, many DBOS instances were connected to a single DBOS\naggregator. The Python-GraphBLAS and OneSparse PostgreSQL implementations\nscaled linearly up to 64 and 32 nodes respectively. These results suggest that\nDBOS collaborative network awareness can be achieved with a negligible increase\nin computing resources.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
