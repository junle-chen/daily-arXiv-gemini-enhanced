{"id": "2510.12642", "pdf": "https://arxiv.org/pdf/2510.12642", "abs": "https://arxiv.org/abs/2510.12642", "authors": ["Meihui Zhang", "Liming Wang", "Chi Zhang", "Zhaojing Luo"], "title": "Aixel: A Unified, Adaptive and Extensible System for AI-powered Data Analysis", "categories": ["cs.DB", "cs.AI"], "comment": null, "summary": "A growing trend in modern data analysis is the integration of data management\nwith learning, guided by accuracy, latency, and cost requirements. In practice,\napplications draw data of different formats from many sources. In the\nmeanwhile, the objectives and budgets change over time. Existing systems handle\nthese applications across databases, analysis libraries, and tuning services.\nSuch fragmentation leads to complex user interaction, limited adaptability,\nsuboptimal performance, and poor extensibility across components. To address\nthese challenges, we present Aixel, a unified, adaptive, and extensible system\nfor AI-powered data analysis. The system organizes work across four layers:\napplication, task, model, and data. The task layer provides a declarative\ninterface to capture user intent, which is parsed into an executable operator\nplan. An optimizer compiles and schedules this plan to meet specified goals in\naccuracy, latency, and cost. The task layer coordinates the execution of data\nand model operators, with built-in support for reuse and caching to improve\nefficiency. The model layer offers versioned storage for index, metadata,\ntensors, and model artifacts. It supports adaptive construction, task-aligned\ndrift detection, and safe updates that reuse shared components. The data layer\nprovides unified data management capabilities, including indexing,\nconstraint-aware discovery, task-aligned selection, and comprehensive feature\nmanagement. With the above designed layers, Aixel delivers a user friendly,\nadaptive, efficient, and extensible system.", "AI": {"tldr": "Aixel\u662f\u4e00\u4e2a\u7edf\u4e00\u3001\u81ea\u9002\u5e94\u548c\u53ef\u6269\u5c55\u7684AI\u9a71\u52a8\u6570\u636e\u5206\u6790\u7cfb\u7edf\u3002", "motivation": "\u73b0\u6709\u7cfb\u7edf\u5728\u6570\u636e\u5e93\u3001\u5206\u6790\u5e93\u548c\u8c03\u4f18\u670d\u52a1\u4e4b\u95f4\u5b58\u5728\u788e\u7247\u5316\uff0c\u5bfc\u81f4\u7528\u6237\u4ea4\u4e92\u590d\u6742\u3001\u9002\u5e94\u6027\u6709\u9650\u3001\u6027\u80fd\u6b20\u4f73\u548c\u7ec4\u4ef6\u6269\u5c55\u6027\u5dee\u3002", "method": "Aixel\u7cfb\u7edf\u5728\u5e94\u7528\u3001\u4efb\u52a1\u3001\u6a21\u578b\u548c\u6570\u636e\u56db\u4e2a\u5c42\u9762\u4e0a\u7ec4\u7ec7\u5de5\u4f5c\u3002\u4efb\u52a1\u5c42\u63d0\u4f9b\u58f0\u660e\u5f0f\u63a5\u53e3\uff0c\u4f18\u5316\u5668\u7f16\u8bd1\u548c\u8c03\u5ea6\u8be5\u8ba1\u5212\u4ee5\u6ee1\u8db3\u7cbe\u5ea6\u3001\u5ef6\u8fdf\u548c\u6210\u672c\u65b9\u9762\u7684\u7279\u5b9a\u76ee\u6807\u3002\u6a21\u578b\u5c42\u4e3a\u7d22\u5f15\u3001\u5143\u6570\u636e\u3001\u5f20\u91cf\u548c\u6a21\u578b\u5de5\u4ef6\u63d0\u4f9b\u7248\u672c\u5316\u5b58\u50a8\u3002\u6570\u636e\u5c42\u63d0\u4f9b\u7edf\u4e00\u7684\u6570\u636e\u7ba1\u7406\u529f\u80fd\uff0c\u5305\u62ec\u7d22\u5f15\u3001\u7ea6\u675f\u611f\u77e5\u53d1\u73b0\u3001\u4efb\u52a1\u5bf9\u9f50\u9009\u62e9\u548c\u7efc\u5408\u7279\u5f81\u7ba1\u7406\u3002", "result": "Aixel\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7528\u6237\u53cb\u597d\u3001\u81ea\u9002\u5e94\u3001\u9ad8\u6548\u548c\u53ef\u6269\u5c55\u7684\u7cfb\u7edf\u3002", "conclusion": "Aixel\u901a\u8fc7\u7edf\u4e00\u7684\u67b6\u6784\u548c\u81ea\u9002\u5e94\u7684\u4f18\u5316\uff0c\u89e3\u51b3\u4e86AI\u9a71\u52a8\u6570\u636e\u5206\u6790\u4e2d\u73b0\u6709\u7cfb\u7edf\u7684\u5c40\u9650\u6027\u3002", "summary_zh": "\u73b0\u4ee3\u6570\u636e\u5206\u6790\u7684\u4e00\u4e2a\u65e5\u76ca\u589e\u957f\u7684\u8d8b\u52bf\u662f\u5c06\u6570\u636e\u7ba1\u7406\u4e0e\u5b66\u4e60\u76f8\u7ed3\u5408\uff0c\u5e76\u4ee5\u51c6\u786e\u6027\u3001\u5ef6\u8fdf\u548c\u6210\u672c\u8981\u6c42\u4e3a\u6307\u5bfc\u3002\u5728\u5b9e\u8df5\u4e2d\uff0c\u5e94\u7528\u7a0b\u5e8f\u4ece\u8bb8\u591a\u6765\u6e90\u63d0\u53d6\u4e0d\u540c\u683c\u5f0f\u7684\u6570\u636e\u3002\u4e0e\u6b64\u540c\u65f6\uff0c\u76ee\u6807\u548c\u9884\u7b97\u968f\u65f6\u95f4\u800c\u53d8\u5316\u3002\u73b0\u6709\u7684\u7cfb\u7edf\u8de8\u6570\u636e\u5e93\u3001\u5206\u6790\u5e93\u548c\u8c03\u4f18\u670d\u52a1\u5904\u7406\u8fd9\u4e9b\u5e94\u7528\u7a0b\u5e8f\u3002\u8fd9\u79cd\u788e\u7247\u5316\u5bfc\u81f4\u590d\u6742\u7684\u7528\u6237\u4ea4\u4e92\u3001\u6709\u9650\u7684\u9002\u5e94\u6027\u3001\u6b21\u4f18\u7684\u6027\u80fd\u4ee5\u53ca\u7ec4\u4ef6\u4e4b\u95f4\u8f83\u5dee\u7684\u53ef\u6269\u5c55\u6027\u3002\u4e3a\u4e86\u5e94\u5bf9\u8fd9\u4e9b\u6311\u6218\uff0c\u6211\u4eec\u63d0\u51fa\u4e86Aixel\uff0c\u4e00\u4e2a\u7edf\u4e00\u7684\u3001\u81ea\u9002\u5e94\u7684\u3001\u53ef\u6269\u5c55\u7684AI\u9a71\u52a8\u7684\u6570\u636e\u5206\u6790\u7cfb\u7edf\u3002\u8be5\u7cfb\u7edf\u5728\u56db\u4e2a\u5c42\u9762\u4e0a\u7ec4\u7ec7\u5de5\u4f5c\uff1a\u5e94\u7528\u5c42\u3001\u4efb\u52a1\u5c42\u3001\u6a21\u578b\u5c42\u548c\u6570\u636e\u5c42\u3002\u4efb\u52a1\u5c42\u63d0\u4f9b\u4e86\u4e00\u4e2a\u58f0\u660e\u5f0f\u63a5\u53e3\u6765\u6355\u83b7\u7528\u6237\u610f\u56fe\uff0c\u8be5\u63a5\u53e3\u88ab\u89e3\u6790\u4e3a\u53ef\u6267\u884c\u7684\u7b97\u5b50\u8ba1\u5212\u3002\u4f18\u5316\u5668\u7f16\u8bd1\u548c\u8c03\u5ea6\u8be5\u8ba1\u5212\uff0c\u4ee5\u6ee1\u8db3\u5728\u51c6\u786e\u6027\u3001\u5ef6\u8fdf\u548c\u6210\u672c\u65b9\u9762\u7684\u7279\u5b9a\u76ee\u6807\u3002\u4efb\u52a1\u5c42\u534f\u8c03\u6570\u636e\u548c\u6a21\u578b\u7b97\u5b50\u7684\u6267\u884c\uff0c\u5e76\u5185\u7f6e\u5bf9\u91cd\u7528\u548c\u7f13\u5b58\u7684\u652f\u6301\uff0c\u4ee5\u63d0\u9ad8\u6548\u7387\u3002\u6a21\u578b\u5c42\u4e3a\u7d22\u5f15\u3001\u5143\u6570\u636e\u3001\u5f20\u91cf\u548c\u6a21\u578b\u5de5\u4ef6\u63d0\u4f9b\u7248\u672c\u5316\u7684\u5b58\u50a8\u3002\u5b83\u652f\u6301\u81ea\u9002\u5e94\u6784\u5efa\u3001\u4efb\u52a1\u5bf9\u9f50\u7684\u6f02\u79fb\u68c0\u6d4b\u4ee5\u53ca\u91cd\u7528\u5171\u4eab\u7ec4\u4ef6\u7684\u5b89\u5168\u66f4\u65b0\u3002\u6570\u636e\u5c42\u63d0\u4f9b\u7edf\u4e00\u7684\u6570\u636e\u7ba1\u7406\u529f\u80fd\uff0c\u5305\u62ec\u7d22\u5f15\u3001\u7ea6\u675f\u611f\u77e5\u53d1\u73b0\u3001\u4efb\u52a1\u5bf9\u9f50\u9009\u62e9\u548c\u7efc\u5408\u7279\u5f81\u7ba1\u7406\u3002\u901a\u8fc7\u4e0a\u8ff0\u8bbe\u8ba1\u7684\u5c42\uff0cAixel\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7528\u6237\u53cb\u597d\u3001\u81ea\u9002\u5e94\u3001\u9ad8\u6548\u548c\u53ef\u6269\u5c55\u7684\u7cfb\u7edf\u3002"}}
{"id": "2510.11813", "pdf": "https://arxiv.org/pdf/2510.11813", "abs": "https://arxiv.org/abs/2510.11813", "authors": ["Marcus Emmanuel Barnes", "Taher A. Ghaleb", "Safwat Hassan"], "title": "Task-Aware Reduction for Scalable LLM-Database Systems", "categories": ["cs.SE", "cs.CL", "cs.DB"], "comment": "Preprint. Accepted for presentation at the Workshop on Language\n  Models and Databases (LMD), co-located with CASCON 2025 (IEEE). The final\n  version will appear in IEEE Xplore", "summary": "Large Language Models (LLMs) are increasingly applied to data-intensive\nworkflows, from database querying to developer observability. Yet the\neffectiveness of these systems is constrained by the volume, verbosity, and\nnoise of real-world text-rich data such as logs, telemetry, and monitoring\nstreams. Feeding such data directly into LLMs is costly, environmentally\nunsustainable, and often misaligned with task objectives. Parallel efforts in\nLLM efficiency have focused on model- or architecture-level optimizations, but\nthe challenge of reducing upstream input verbosity remains underexplored. In\nthis paper, we argue for treating the token budget of an LLM as an attention\nbudget and elevating task-aware text reduction as a first-class design\nprinciple for language -- data systems. We position input-side reduction not as\ncompression, but as attention allocation: prioritizing information most\nrelevant to downstream tasks. We outline open research challenges for building\nbenchmarks, designing adaptive reduction pipelines, and integrating\ntoken-budget--aware preprocessing into database and retrieval systems. Our\nvision is to channel scarce attention resources toward meaningful signals in\nnoisy, data-intensive workflows, enabling scalable, accurate, and sustainable\nLLM--data integration.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
{"id": "2510.12280", "pdf": "https://arxiv.org/pdf/2510.12280", "abs": "https://arxiv.org/abs/2510.12280", "authors": ["Yosuke Bando", "Akinobu Mita", "Kazuhiro Hiwada", "Shintaro Sano", "Tomoya Suzuki", "Yu Nakanishi", "Kazutaka Tomida", "Hirotsugu Kajihara", "Akiyuki Kaneko", "Daisuke Taki", "Yukimasa Miyamoto", "Tomokazu Yoshida", "Tatsuo Shiozawa"], "title": "Analysis and Evaluation of Using Microsecond-Latency Memory for In-Memory Indices and Caches in SSD-Based Key-Value Stores", "categories": ["cs.PF", "cs.DB"], "comment": null, "summary": "When key-value (KV) stores use SSDs for storing a large number of items,\noftentimes they also require large in-memory data structures including indices\nand caches to be traversed to reduce IOs. This paper considers offloading most\nof such data structures from the costly host DRAM to secondary memory whose\nlatency is in the microsecond range, an order of magnitude longer than those of\ncurrently available DIMM-mounted or CXL memory devices. While emerging\nmicrosecond-latency memory is likely to cost much less than DRAM, it can\nsignificantly slow down SSD-based KV stores if naively employed. This paper\nanalyzes and evaluates the impact of microsecond-level memory latency on the KV\noperation throughput. Our analysis finds that a well-known latency-hiding\ntechnique of software prefetching for long-latency memory from user-level\nthreads is effective. The novelty of our analysis lies in modeling how the\ninterplay between prefetching and IO affects performance, from which we derive\nan equation that well explains the throughput degradation due to long memory\nlatency. The model tells us that the presence of IO significantly enhances the\ntolerance to memory latency, leading to a finding that SSD-based KV stores can\nbe made latency-tolerant without devising new techniques for\nmicrosecond-latency memory. To confirm this, we design a microbenchmark as well\nas modify existing SSD-based KV stores so that they issue prefetches from\nuser-level threads, and run them while placing most of in-memory data\nstructures on FPGA-based memory with adjustable microsecond latency. The\nresults demonstrate that their KV operation throughputs can be well explained\nby our model, and the modified KV stores achieve near-DRAM throughputs for up\nto a memory latency of 5 microseconds. This suggests the possibility that\nSSD-based KV stores can use microsecond-latency memory as a cost-effective\nalternative to the host DRAM.", "AI": {"tldr": "\u8fbe\u5230API\u914d\u989d\u9650\u5236\uff0c\u8bf7\u660e\u5929\u518d\u8bd5", "motivation": "Error: API quota exceeded", "method": "Error: API quota exceeded", "result": "Error: API quota exceeded", "conclusion": "\u8bf7\u8054\u7cfb\u7ba1\u7406\u5458\u6216\u7b49\u5f85\u660e\u5929API\u914d\u989d\u91cd\u7f6e\u3002"}}
